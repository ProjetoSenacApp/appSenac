/**
 * @fileoverview added by tsickle
 * Generated from: angularfire2.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { asyncScheduler, queueScheduler } from 'rxjs';
import { observeOn, subscribeOn, tap } from 'rxjs/operators';
/**
 * @return {?}
 */
function noop() {
}
/**
 * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.
 */
// tslint:disable-next-line:class-name
export class ɵZoneScheduler {
    /**
     * @param {?} zone
     * @param {?=} delegate
     */
    constructor(zone, delegate = queueScheduler) {
        this.zone = zone;
        this.delegate = delegate;
    }
    /**
     * @return {?}
     */
    now() {
        return this.delegate.now();
    }
    /**
     * @param {?} work
     * @param {?=} delay
     * @param {?=} state
     * @return {?}
     */
    schedule(work, delay, state) {
        /** @type {?} */
        const targetZone = this.zone;
        // Wrap the specified work function to make sure that if nested scheduling takes place the
        // work is executed in the correct zone
        /** @type {?} */
        const workInZone = (/**
         * @this {?}
         * @param {?} state
         * @return {?}
         */
        function (state) {
            targetZone.runGuarded((/**
             * @return {?}
             */
            () => {
                work.apply(this, [state]);
            }));
        });
        // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done
        // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that
        // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.
        return this.delegate.schedule(workInZone, delay, state);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    ɵZoneScheduler.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    ɵZoneScheduler.prototype.delegate;
}
// tslint:disable-next-line:class-name
/**
 * @template T
 */
export class ɵBlockUntilFirstOperator {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        this.task = null;
    }
    /**
     * @param {?} subscriber
     * @param {?} source
     * @return {?}
     */
    call(subscriber, source) {
        /** @type {?} */
        const unscheduleTask = this.unscheduleTask.bind(this);
        this.task = this.zone.run((/**
         * @return {?}
         */
        () => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop)));
        return source.pipe(tap({ next: unscheduleTask, complete: unscheduleTask, error: unscheduleTask })).subscribe(subscriber).add(unscheduleTask);
    }
    /**
     * @private
     * @return {?}
     */
    unscheduleTask() {
        // maybe this is a race condition, invoke in a timeout
        // hold for 10ms while I try to figure out what is going on
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.task != null && this.task.state === 'scheduled') {
                this.task.invoke();
                this.task = null;
            }
        }), 10);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    ɵBlockUntilFirstOperator.prototype.task;
    /**
     * @type {?}
     * @private
     */
    ɵBlockUntilFirstOperator.prototype.zone;
}
// tslint:disable-next-line:class-name
export class ɵAngularFireSchedulers {
    /**
     * @param {?} ngZone
     */
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.outsideAngular = ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => new ɵZoneScheduler(Zone.current)));
        this.insideAngular = ngZone.run((/**
         * @return {?}
         */
        () => new ɵZoneScheduler(Zone.current, asyncScheduler)));
    }
}
if (false) {
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.outsideAngular;
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.insideAngular;
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.ngZone;
}
/**
 * Operator to block the zone until the first value has been emitted or the observable
 * has completed/errored. This is used to make sure that universal waits until the first
 * value from firebase but doesn't block the zone forever since the firebase subscription
 * is still alive.
 * @param {?} schedulers
 * @return {?}
 */
export function ɵkeepUnstableUntilFirstFactory(schedulers) {
    return (/**
     * @template T
     * @param {?} obs$
     * @return {?}
     */
    function keepUnstableUntilFirst(obs$) {
        obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));
        return obs$.pipe(
        // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)
        subscribeOn(schedulers.outsideAngular), 
        // Run operators inside the angular zone (e.g. side effects via tap())
        observeOn(schedulers.insideAngular)
        // INVESTIGATE https://github.com/angular/angularfire/pull/2315
        // share()
        );
    });
}
// DEBUG quick debugger function for inline logging that typescript doesn't complain about
//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a
//       verbose mode for AngularFire in a future release that uses something like this in multiple places
//       usage: () => log('something') || returnValue
// const log = (...args: any[]): false => { console.log(...args); return false }
// The problem here are things like ngOnDestroy are missing, then triggering the service
// rather than dig too far; I'm capturing these as I go.
/** @type {?} */
const noopFunctions = ['ngOnDestroy'];
// INVESTIGATE should we make the Proxy revokable and do some cleanup?
//             right now it's fairly simple but I'm sure this will grow in complexity
/** @type {?} */
export const ɵlazySDKProxy = (/**
 * @param {?} klass
 * @param {?} observable
 * @param {?} zone
 * @return {?}
 */
(klass, observable, zone) => {
    return new Proxy(klass, {
        get: (/**
         * @param {?} _
         * @param {?} name
         * @return {?}
         */
        (_, name) => zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            if (klass[name]) {
                return klass[name];
            }
            if (noopFunctions.includes(name)) {
                return (/**
                 * @return {?}
                 */
                () => {
                });
            }
            /** @type {?} */
            const promise = observable.toPromise().then((/**
             * @param {?} mod
             * @return {?}
             */
            mod => {
                /** @type {?} */
                const ret = mod && mod[name];
                // TODO move to proper type guards
                if (typeof ret === 'function') {
                    return ret.bind(mod);
                }
                else if (ret && ret.then) {
                    return ret.then((/**
                     * @param {?} res
                     * @return {?}
                     */
                    (res) => zone.run((/**
                     * @return {?}
                     */
                    () => res))));
                }
                else {
                    return zone.run((/**
                     * @return {?}
                     */
                    () => ret));
                }
            }));
            // recurse the proxy
            return new Proxy((/**
             * @return {?}
             */
            () => undefined), {
                get: (/**
                 * @param {?} _
                 * @param {?} name
                 * @return {?}
                 */
                (_, name) => promise[name]),
                // TODO handle callbacks as transparently as I can
                apply: (/**
                 * @param {?} self
                 * @param {?} _
                 * @param {?} args
                 * @return {?}
                 */
                (self, _, args) => promise.then((/**
                 * @param {?} it
                 * @return {?}
                 */
                it => it && it(...args))))
            });
        })))
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcmZpcmUyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvcmUvYW5ndWxhcmZpcmUyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUNMLGNBQWMsRUFHZCxjQUFjLEVBTWYsTUFBTSxNQUFNLENBQUM7QUFDZCxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQUU3RCxTQUFTLElBQUk7QUFDYixDQUFDOzs7OztBQU1ELE1BQU0sT0FBTyxjQUFjOzs7OztJQUN6QixZQUFvQixJQUFTLEVBQVUsV0FBZ0IsY0FBYztRQUFqRCxTQUFJLEdBQUosSUFBSSxDQUFLO1FBQVUsYUFBUSxHQUFSLFFBQVEsQ0FBc0I7SUFDckUsQ0FBQzs7OztJQUVELEdBQUc7UUFDRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDN0IsQ0FBQzs7Ozs7OztJQUVELFFBQVEsQ0FBQyxJQUF1RCxFQUFFLEtBQWMsRUFBRSxLQUFXOztjQUNyRixVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUk7Ozs7Y0FHdEIsVUFBVTs7Ozs7UUFBRyxVQUFxQyxLQUFVO1lBQ2hFLFVBQVUsQ0FBQyxVQUFVOzs7WUFBQyxHQUFHLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUM1QixDQUFDLEVBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQTtRQUVELHNHQUFzRztRQUN0RyxpR0FBaUc7UUFDakcsK0dBQStHO1FBQy9HLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMxRCxDQUFDO0NBQ0Y7Ozs7OztJQXRCYSw4QkFBaUI7Ozs7O0lBQUUsa0NBQXNDOzs7Ozs7QUF5QnZFLE1BQU0sT0FBTyx3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RUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFDLENBQUE7YUFDaEUsQ0FDRixDQUFDO1FBQ0osQ0FBQyxFQUFDLENBQUE7S0FDSCxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIGFzeW5jU2NoZWR1bGVyLFxuICBPYnNlcnZhYmxlLFxuICBPcGVyYXRvcixcbiAgcXVldWVTY2hlZHVsZXIsXG4gIFNjaGVkdWxlckFjdGlvbixcbiAgU2NoZWR1bGVyTGlrZSxcbiAgU3Vic2NyaWJlcixcbiAgU3Vic2NyaXB0aW9uLFxuICBUZWFyZG93bkxvZ2ljXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgb2JzZXJ2ZU9uLCBzdWJzY3JpYmVPbiwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyB0YXNrcyBzbyB0aGF0IHRoZXkgYXJlIGludm9rZWQgaW5zaWRlIHRoZSBab25lIHRoYXQgaXMgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNsYXNzLW5hbWVcbmV4cG9ydCBjbGFzcyDJtVpvbmVTY2hlZHVsZXIgaW1wbGVtZW50cyBTY2hlZHVsZXJMaWtlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBhbnksIHByaXZhdGUgZGVsZWdhdGU6IGFueSA9IHF1ZXVlU2NoZWR1bGVyKSB7XG4gIH1cblxuICBub3coKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubm93KCk7XG4gIH1cblxuICBzY2hlZHVsZSh3b3JrOiAodGhpczogU2NoZWR1bGVyQWN0aW9uPGFueT4sIHN0YXRlPzogYW55KSA9PiB2b2lkLCBkZWxheT86IG51bWJlciwgc3RhdGU/OiBhbnkpOiBTdWJzY3JpcHRpb24ge1xuICAgIGNvbnN0IHRhcmdldFpvbmUgPSB0aGlzLnpvbmU7XG4gICAgLy8gV3JhcCB0aGUgc3BlY2lmaWVkIHdvcmsgZnVuY3Rpb24gdG8gbWFrZSBzdXJlIHRoYXQgaWYgbmVzdGVkIHNjaGVkdWxpbmcgdGFrZXMgcGxhY2UgdGhlXG4gICAgLy8gd29yayBpcyBleGVjdXRlZCBpbiB0aGUgY29ycmVjdCB6b25lXG4gICAgY29uc3Qgd29ya0luWm9uZSA9IGZ1bmN0aW9uKHRoaXM6IFNjaGVkdWxlckFjdGlvbjxhbnk+LCBzdGF0ZTogYW55KSB7XG4gICAgICB0YXJnZXRab25lLnJ1bkd1YXJkZWQoKCkgPT4ge1xuICAgICAgICB3b3JrLmFwcGx5KHRoaXMsIFtzdGF0ZV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFNjaGVkdWxpbmcgaXRzZWxmIG5lZWRzIHRvIGJlIHJ1biBpbiB6b25lIHRvIGVuc3VyZSBzZXRJbnRlcnZhbCBjYWxscyBmb3IgYXN5bmMgc2NoZWR1bGluZyBhcmUgZG9uZVxuICAgIC8vIGluc2lkZSB0aGUgY29ycmVjdCB6b25lLiBUaGlzIHNjaGVkdWxlciBuZWVkcyB0byBzY2hlZHVsZSBhc3luY2hyb25vdXNseSBhbHdheXMgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyBmaXJlYmFzZSBlbWlzc2lvbnMgYXJlIG5ldmVyIHN5bmNocm9ub3VzLiBTcGVjaWZ5aW5nIGEgZGVsYXkgY2F1c2VzIGlzc3VlcyB3aXRoIHRoZSBxdWV1ZVNjaGVkdWxlciBkZWxlZ2F0ZS5cbiAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zY2hlZHVsZSh3b3JrSW5ab25lLCBkZWxheSwgc3RhdGUpO1xuICB9XG59XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjbGFzcy1uYW1lXG5leHBvcnQgY2xhc3MgybVCbG9ja1VudGlsRmlyc3RPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgcHJpdmF0ZSB0YXNrOiBNYWNyb1Rhc2sgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHpvbmU6IGFueSkge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBUZWFyZG93bkxvZ2ljIHtcbiAgICBjb25zdCB1bnNjaGVkdWxlVGFzayA9IHRoaXMudW5zY2hlZHVsZVRhc2suYmluZCh0aGlzKTtcbiAgICB0aGlzLnRhc2sgPSB0aGlzLnpvbmUucnVuKCgpID0+IFpvbmUuY3VycmVudC5zY2hlZHVsZU1hY3JvVGFzaygnZmlyZWJhc2Vab25lQmxvY2snLCBub29wLCB7fSwgbm9vcCwgbm9vcCkpO1xuXG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgdGFwKHsgbmV4dDogdW5zY2hlZHVsZVRhc2ssIGNvbXBsZXRlOiB1bnNjaGVkdWxlVGFzaywgZXJyb3I6IHVuc2NoZWR1bGVUYXNrIH0pXG4gICAgKS5zdWJzY3JpYmUoc3Vic2NyaWJlcikuYWRkKHVuc2NoZWR1bGVUYXNrKTtcbiAgfVxuXG4gIHByaXZhdGUgdW5zY2hlZHVsZVRhc2soKSB7XG4gICAgLy8gbWF5YmUgdGhpcyBpcyBhIHJhY2UgY29uZGl0aW9uLCBpbnZva2UgaW4gYSB0aW1lb3V0XG4gICAgLy8gaG9sZCBmb3IgMTBtcyB3aGlsZSBJIHRyeSB0byBmaWd1cmUgb3V0IHdoYXQgaXMgZ29pbmcgb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRhc2sgIT0gbnVsbCAmJiB0aGlzLnRhc2suc3RhdGUgPT09ICdzY2hlZHVsZWQnKSB7XG4gICAgICAgIHRoaXMudGFzay5pbnZva2UoKTtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCAxMCk7XG4gIH1cbn1cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNsYXNzLW5hbWVcbmV4cG9ydCBjbGFzcyDJtUFuZ3VsYXJGaXJlU2NoZWR1bGVycyB7XG4gIHB1YmxpYyByZWFkb25seSBvdXRzaWRlQW5ndWxhcjogybVab25lU2NoZWR1bGVyO1xuICBwdWJsaWMgcmVhZG9ubHkgaW5zaWRlQW5ndWxhcjogybVab25lU2NoZWR1bGVyO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuZ1pvbmU6IE5nWm9uZSkge1xuICAgIHRoaXMub3V0c2lkZUFuZ3VsYXIgPSBuZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gbmV3IMm1Wm9uZVNjaGVkdWxlcihab25lLmN1cnJlbnQpKTtcbiAgICB0aGlzLmluc2lkZUFuZ3VsYXIgPSBuZ1pvbmUucnVuKCgpID0+IG5ldyDJtVpvbmVTY2hlZHVsZXIoWm9uZS5jdXJyZW50LCBhc3luY1NjaGVkdWxlcikpO1xuICB9XG59XG5cbi8qKlxuICogT3BlcmF0b3IgdG8gYmxvY2sgdGhlIHpvbmUgdW50aWwgdGhlIGZpcnN0IHZhbHVlIGhhcyBiZWVuIGVtaXR0ZWQgb3IgdGhlIG9ic2VydmFibGVcbiAqIGhhcyBjb21wbGV0ZWQvZXJyb3JlZC4gVGhpcyBpcyB1c2VkIHRvIG1ha2Ugc3VyZSB0aGF0IHVuaXZlcnNhbCB3YWl0cyB1bnRpbCB0aGUgZmlyc3RcbiAqIHZhbHVlIGZyb20gZmlyZWJhc2UgYnV0IGRvZXNuJ3QgYmxvY2sgdGhlIHpvbmUgZm9yZXZlciBzaW5jZSB0aGUgZmlyZWJhc2Ugc3Vic2NyaXB0aW9uXG4gKiBpcyBzdGlsbCBhbGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIMm1a2VlcFVuc3RhYmxlVW50aWxGaXJzdEZhY3Rvcnkoc2NoZWR1bGVyczogybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtlZXBVbnN0YWJsZVVudGlsRmlyc3Q8VD4ob2JzJDogT2JzZXJ2YWJsZTxUPik6IE9ic2VydmFibGU8VD4ge1xuICAgIG9icyQgPSBvYnMkLmxpZnQoXG4gICAgICBuZXcgybVCbG9ja1VudGlsRmlyc3RPcGVyYXRvcihzY2hlZHVsZXJzLm5nWm9uZSlcbiAgICApO1xuXG4gICAgcmV0dXJuIG9icyQucGlwZShcbiAgICAgIC8vIFJ1biB0aGUgc3Vic2NyaWJlIGJvZHkgb3V0c2lkZSBvZiBBbmd1bGFyIChlLmcuIGNhbGxpbmcgRmlyZWJhc2UgU0RLIHRvIGFkZCBhIGxpc3RlbmVyIHRvIGEgY2hhbmdlIGV2ZW50KVxuICAgICAgc3Vic2NyaWJlT24oc2NoZWR1bGVycy5vdXRzaWRlQW5ndWxhciksXG4gICAgICAvLyBSdW4gb3BlcmF0b3JzIGluc2lkZSB0aGUgYW5ndWxhciB6b25lIChlLmcuIHNpZGUgZWZmZWN0cyB2aWEgdGFwKCkpXG4gICAgICBvYnNlcnZlT24oc2NoZWR1bGVycy5pbnNpZGVBbmd1bGFyKVxuICAgICAgLy8gSU5WRVNUSUdBVEUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhcmZpcmUvcHVsbC8yMzE1XG4gICAgICAvLyBzaGFyZSgpXG4gICAgKTtcbiAgfTtcbn1cblxuLy8gdHNsaW50OmRpc2FibGU6YmFuLXR5cGVzXG50eXBlIEZ1bmN0aW9uUHJvcGVydHlOYW1lczxUPiA9IHsgW0sgaW4ga2V5b2YgVF06IFRbS10gZXh0ZW5kcyBGdW5jdGlvbiA/IEsgOiBuZXZlciB9W2tleW9mIFRdO1xudHlwZSBQcm9taXNlUmV0dXJuaW5nRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+ID0ge1xuICBbSyBpbiBGdW5jdGlvblByb3BlcnR5TmFtZXM8VD5dOiBSZXR1cm5UeXBlPFRbS10+IGV4dGVuZHMgUHJvbWlzZTxhbnk+ID8gSyA6IG5ldmVyXG59W0Z1bmN0aW9uUHJvcGVydHlOYW1lczxUPl07XG50eXBlIE5vblByb21pc2VSZXR1cm5pbmdGdW5jdGlvblByb3BlcnR5TmFtZXM8VD4gPSB7XG4gIFtLIGluIEZ1bmN0aW9uUHJvcGVydHlOYW1lczxUPl06IFJldHVyblR5cGU8VFtLXT4gZXh0ZW5kcyBQcm9taXNlPGFueT4gPyBuZXZlciA6IEtcbn1bRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+XTtcbnR5cGUgTm9uRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+ID0geyBbSyBpbiBrZXlvZiBUXTogVFtLXSBleHRlbmRzIEZ1bmN0aW9uID8gbmV2ZXIgOiBLIH1ba2V5b2YgVF07XG4vLyB0c2xpbnQ6ZW5hYmxlOmJhbi10eXBlc1xuXG5leHBvcnQgdHlwZSDJtVByb21pc2VQcm94eTxUPiA9IHsgW0sgaW4gTm9uRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+XTogUHJvbWlzZTxUW0tdPiB9ICZcbiAgeyBbSyBpbiBOb25Qcm9taXNlUmV0dXJuaW5nRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+XTogKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VFtLXT4pID0+IFByb21pc2U8UmV0dXJuVHlwZTxUW0tdPj4gfSAmXG4gIHsgW0sgaW4gUHJvbWlzZVJldHVybmluZ0Z1bmN0aW9uUHJvcGVydHlOYW1lczxUPl06ICguLi5hcmdzOiBQYXJhbWV0ZXJzPFRbS10+KSA9PiBSZXR1cm5UeXBlPFRbS10+IH07XG5cblxuLy8gREVCVUcgcXVpY2sgZGVidWdnZXIgZnVuY3Rpb24gZm9yIGlubGluZSBsb2dnaW5nIHRoYXQgdHlwZXNjcmlwdCBkb2Vzbid0IGNvbXBsYWluIGFib3V0XG4vLyAgICAgICB3cm90ZSBpdCBmb3IgZGVidWdnaW5nIHRoZSDJtWxhenlTREtQcm94eSwgY29tbWVudGluZyBvdXQgZm9yIG5vdzsgc2hvdWxkIGNvbnNpZGVyIGV4cG9zaW5nIGFcbi8vICAgICAgIHZlcmJvc2UgbW9kZSBmb3IgQW5ndWxhckZpcmUgaW4gYSBmdXR1cmUgcmVsZWFzZSB0aGF0IHVzZXMgc29tZXRoaW5nIGxpa2UgdGhpcyBpbiBtdWx0aXBsZSBwbGFjZXNcbi8vICAgICAgIHVzYWdlOiAoKSA9PiBsb2coJ3NvbWV0aGluZycpIHx8IHJldHVyblZhbHVlXG4vLyBjb25zdCBsb2cgPSAoLi4uYXJnczogYW55W10pOiBmYWxzZSA9PiB7IGNvbnNvbGUubG9nKC4uLmFyZ3MpOyByZXR1cm4gZmFsc2UgfVxuXG4vLyBUaGUgcHJvYmxlbSBoZXJlIGFyZSB0aGluZ3MgbGlrZSBuZ09uRGVzdHJveSBhcmUgbWlzc2luZywgdGhlbiB0cmlnZ2VyaW5nIHRoZSBzZXJ2aWNlXG4vLyByYXRoZXIgdGhhbiBkaWcgdG9vIGZhcjsgSSdtIGNhcHR1cmluZyB0aGVzZSBhcyBJIGdvLlxuY29uc3Qgbm9vcEZ1bmN0aW9ucyA9IFsnbmdPbkRlc3Ryb3knXTtcblxuLy8gSU5WRVNUSUdBVEUgc2hvdWxkIHdlIG1ha2UgdGhlIFByb3h5IHJldm9rYWJsZSBhbmQgZG8gc29tZSBjbGVhbnVwP1xuLy8gICAgICAgICAgICAgcmlnaHQgbm93IGl0J3MgZmFpcmx5IHNpbXBsZSBidXQgSSdtIHN1cmUgdGhpcyB3aWxsIGdyb3cgaW4gY29tcGxleGl0eVxuZXhwb3J0IGNvbnN0IMm1bGF6eVNES1Byb3h5ID0gKGtsYXNzOiBhbnksIG9ic2VydmFibGU6IE9ic2VydmFibGU8YW55Piwgem9uZTogTmdab25lKSA9PiB7XG4gIHJldHVybiBuZXcgUHJveHkoa2xhc3MsIHtcbiAgICBnZXQ6IChfLCBuYW1lOiBzdHJpbmcpID0+IHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgaWYgKGtsYXNzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBrbGFzc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmIChub29wRnVuY3Rpb25zLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9taXNlID0gb2JzZXJ2YWJsZS50b1Byb21pc2UoKS50aGVuKG1vZCA9PiB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1vZCAmJiBtb2RbbmFtZV07XG4gICAgICAgIC8vIFRPRE8gbW92ZSB0byBwcm9wZXIgdHlwZSBndWFyZHNcbiAgICAgICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gcmV0LmJpbmQobW9kKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXQgJiYgcmV0LnRoZW4pIHtcbiAgICAgICAgICByZXR1cm4gcmV0LnRoZW4oKHJlczogYW55KSA9PiB6b25lLnJ1bigoKSA9PiByZXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gem9uZS5ydW4oKCkgPT4gcmV0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyByZWN1cnNlIHRoZSBwcm94eVxuICAgICAgcmV0dXJuIG5ldyBQcm94eSgoKSA9PiB1bmRlZmluZWQsIHtcbiAgICAgICAgICBnZXQ6IChfLCBuYW1lKSA9PiBwcm9taXNlW25hbWVdLFxuICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGNhbGxiYWNrcyBhcyB0cmFuc3BhcmVudGx5IGFzIEkgY2FuXG4gICAgICAgICAgYXBwbHk6IChzZWxmLCBfLCBhcmdzKSA9PiBwcm9taXNlLnRoZW4oaXQgPT4gaXQgJiYgaXQoLi4uYXJncykpXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSlcbiAgfSk7XG59O1xuIl19