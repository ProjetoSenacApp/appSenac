/**
 * @fileoverview added by tsickle
 * Generated from: firebase.app.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, InjectionToken, NgModule, NgZone, Optional, PLATFORM_ID, VERSION as NG_VERSION, Version } from '@angular/core';
import firebase from 'firebase/app';
/**
 * @record
 */
export function FirebaseOptions() { }
/**
 * @record
 */
export function FirebaseAppConfig() { }
/** @type {?} */
export const FIREBASE_OPTIONS = new InjectionToken('angularfire2.app.options');
/** @type {?} */
export const FIREBASE_APP_NAME = new InjectionToken('angularfire2.app.nameOrConfig');
// Have to implement as we need to return a class from the provider, we should consider exporting
// this in the firebase/app types as this is our highest risk of breaks
export class FirebaseApp {
}
if (false) {
    /** @type {?} */
    FirebaseApp.prototype.name;
    /** @type {?} */
    FirebaseApp.prototype.options;
    /** @type {?} */
    FirebaseApp.prototype.analytics;
    /** @type {?} */
    FirebaseApp.prototype.auth;
    /** @type {?} */
    FirebaseApp.prototype.database;
    /** @type {?} */
    FirebaseApp.prototype.messaging;
    /** @type {?} */
    FirebaseApp.prototype.performance;
    /** @type {?} */
    FirebaseApp.prototype.storage;
    /** @type {?} */
    FirebaseApp.prototype.delete;
    /** @type {?} */
    FirebaseApp.prototype.firestore;
    /** @type {?} */
    FirebaseApp.prototype.functions;
    /** @type {?} */
    FirebaseApp.prototype.remoteConfig;
}
/** @type {?} */
export const VERSION = new Version('6.0.3');
/**
 * @param {?} options
 * @param {?} zone
 * @param {?=} nameOrConfig
 * @return {?}
 */
export function ɵfirebaseAppFactory(options, zone, nameOrConfig) {
    /** @type {?} */
    const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';
    /** @type {?} */
    const config = typeof nameOrConfig === 'object' && nameOrConfig || {};
    config.name = config.name || name;
    // Added any due to some inconsistency between @firebase/app and firebase types
    /** @type {?} */
    const existingApp = (/** @type {?} */ (firebase.apps.filter((/**
     * @param {?} app
     * @return {?}
     */
    app => app && app.name === config.name))[0]));
    // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any
    // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206
    return (/** @type {?} */ ((existingApp || zone.runOutsideAngular((/**
     * @return {?}
     */
    () => firebase.initializeApp(options, (/** @type {?} */ (config))))))));
}
/** @type {?} */
const FIREBASE_APP_PROVIDER = {
    provide: FirebaseApp,
    useFactory: ɵfirebaseAppFactory,
    deps: [
        FIREBASE_OPTIONS,
        NgZone,
        [new Optional(), FIREBASE_APP_NAME]
    ]
};
export class AngularFireModule {
    // tslint:disable-next-line:ban-types
    /**
     * @param {?} platformId
     */
    constructor(platformId) {
        firebase.registerVersion('angularfire', VERSION.full, platformId.toString());
        firebase.registerVersion('angular', NG_VERSION.full);
    }
    /**
     * @param {?} options
     * @param {?=} nameOrConfig
     * @return {?}
     */
    static initializeApp(options, nameOrConfig) {
        return {
            ngModule: AngularFireModule,
            providers: [
                { provide: FIREBASE_OPTIONS, useValue: options },
                { provide: FIREBASE_APP_NAME, useValue: nameOrConfig }
            ]
        };
    }
}
AngularFireModule.decorators = [
    { type: NgModule, args: [{
                providers: [FIREBASE_APP_PROVIDER]
            },] }
];
/** @nocollapse */
AngularFireModule.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlyZWJhc2UuYXBwLm1vZHVsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2ZpcmViYXNlLmFwcC5tb2R1bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQ0wsTUFBTSxFQUFFLGNBQWMsRUFBdUIsUUFBUSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLE9BQU8sSUFBSSxVQUFVLEVBQUUsT0FBTyxFQUNySCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLFFBQVEsTUFBTSxjQUFjLENBQUM7Ozs7QUFJcEMscUNBRUM7Ozs7QUFFRCx1Q0FFQzs7QUFFRCxNQUFNLE9BQU8sZ0JBQWdCLEdBQUcsSUFBSSxjQUFjLENBQWtCLDBCQUEwQixDQUFDOztBQUMvRixNQUFNLE9BQU8saUJBQWlCLEdBQUcsSUFBSSxjQUFjLENBQXlDLCtCQUErQixDQUFDOzs7QUFJNUgsTUFBTSxPQUFPLFdBQVc7Q0FhdkI7OztJQVpDLDJCQUFhOztJQUNiLDhCQUFZOztJQUNaLGdDQUFxQzs7SUFDckMsMkJBQXNCOztJQUN0QiwrQkFBc0Q7O0lBQ3RELGdDQUFxQzs7SUFDckMsa0NBQTJDOztJQUMzQyw4QkFBcUQ7O0lBQ3JELDZCQUE0Qjs7SUFDNUIsZ0NBQXFDOztJQUNyQyxnQ0FBb0Q7O0lBQ3BELG1DQUE4Qzs7O0FBR2hELE1BQU0sT0FBTyxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsc0JBQXNCLENBQUM7Ozs7Ozs7QUFFMUQsTUFBTSxVQUFVLG1CQUFtQixDQUFDLE9BQXdCLEVBQUUsSUFBWSxFQUFFLFlBQWdEOztVQUNwSCxJQUFJLEdBQUcsT0FBTyxZQUFZLEtBQUssUUFBUSxJQUFJLFlBQVksSUFBSSxXQUFXOztVQUN0RSxNQUFNLEdBQUcsT0FBTyxZQUFZLEtBQUssUUFBUSxJQUFJLFlBQVksSUFBSSxFQUFFO0lBQ3JFLE1BQU0sQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUM7OztVQUU1QixXQUFXLEdBQUcsbUJBQUEsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNOzs7O0lBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLEVBQU87SUFDMUYsa0dBQWtHO0lBQ2xHLDZFQUE2RTtJQUM3RSxPQUFPLG1CQUFBLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxpQkFBaUI7OztJQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLG1CQUFBLE1BQU0sRUFBTyxDQUFDLEVBQUMsQ0FBQyxFQUFlLENBQUM7QUFDdEgsQ0FBQzs7TUFFSyxxQkFBcUIsR0FBRztJQUM1QixPQUFPLEVBQUUsV0FBVztJQUNwQixVQUFVLEVBQUUsbUJBQW1CO0lBQy9CLElBQUksRUFBRTtRQUNKLGdCQUFnQjtRQUNoQixNQUFNO1FBQ04sQ0FBQyxJQUFJLFFBQVEsRUFBRSxFQUFFLGlCQUFpQixDQUFDO0tBQ3BDO0NBQ0Y7QUFLRCxNQUFNLE9BQU8saUJBQWlCOzs7OztJQVk1QixZQUFpQyxVQUFrQjtRQUNqRCxRQUFRLENBQUMsZUFBZSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQzdFLFFBQVEsQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2RCxDQUFDOzs7Ozs7SUFkRCxNQUFNLENBQUMsYUFBYSxDQUFDLE9BQXdCLEVBQUUsWUFBeUM7UUFDdEYsT0FBTztZQUNMLFFBQVEsRUFBRSxpQkFBaUI7WUFDM0IsU0FBUyxFQUFFO2dCQUNULEVBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUM7Z0JBQzlDLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUM7YUFDckQ7U0FDRixDQUFDO0lBQ0osQ0FBQzs7O1lBWkYsUUFBUSxTQUFDO2dCQUNSLFNBQVMsRUFBRSxDQUFDLHFCQUFxQixDQUFDO2FBQ25DOzs7O1lBYThDLE1BQU0sdUJBQXRDLE1BQU0sU0FBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSW5qZWN0LCBJbmplY3Rpb25Ub2tlbiwgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGUsIE5nWm9uZSwgT3B0aW9uYWwsIFBMQVRGT1JNX0lELCBWRVJTSU9OIGFzIE5HX1ZFUlNJT04sIFZlcnNpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IGFuYWx5dGljcywgYXBwLCBhdXRoLCBkYXRhYmFzZSwgZmlyZXN0b3JlLCBmdW5jdGlvbnMsIG1lc3NhZ2luZywgcGVyZm9ybWFuY2UsIHJlbW90ZUNvbmZpZywgc3RvcmFnZSB9IGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5cbi8vIElOVkVTVElHQVRFIFB1YmxpYyB0eXBlcyBkb24ndCBleHBvc2UgRmlyZWJhc2VPcHRpb25zIG9yIEZpcmViYXNlQXBwQ29uZmlnLCBpcyB0aGlzIHRoZSBjYXNlIGFueWxvbmdlcj9cbmV4cG9ydCBpbnRlcmZhY2UgRmlyZWJhc2VPcHRpb25zIHtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpcmViYXNlQXBwQ29uZmlnIHtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgY29uc3QgRklSRUJBU0VfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxGaXJlYmFzZU9wdGlvbnM+KCdhbmd1bGFyZmlyZTIuYXBwLm9wdGlvbnMnKTtcbmV4cG9ydCBjb25zdCBGSVJFQkFTRV9BUFBfTkFNRSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxzdHJpbmcgfCBGaXJlYmFzZUFwcENvbmZpZyB8IHVuZGVmaW5lZD4oJ2FuZ3VsYXJmaXJlMi5hcHAubmFtZU9yQ29uZmlnJyk7XG5cbi8vIEhhdmUgdG8gaW1wbGVtZW50IGFzIHdlIG5lZWQgdG8gcmV0dXJuIGEgY2xhc3MgZnJvbSB0aGUgcHJvdmlkZXIsIHdlIHNob3VsZCBjb25zaWRlciBleHBvcnRpbmdcbi8vIHRoaXMgaW4gdGhlIGZpcmViYXNlL2FwcCB0eXBlcyBhcyB0aGlzIGlzIG91ciBoaWdoZXN0IHJpc2sgb2YgYnJlYWtzXG5leHBvcnQgY2xhc3MgRmlyZWJhc2VBcHAgaW1wbGVtZW50cyBQYXJ0aWFsPGFwcC5BcHA+IHtcbiAgbmFtZTogc3RyaW5nO1xuICBvcHRpb25zOiB7fTtcbiAgYW5hbHl0aWNzOiAoKSA9PiBhbmFseXRpY3MuQW5hbHl0aWNzO1xuICBhdXRoOiAoKSA9PiBhdXRoLkF1dGg7XG4gIGRhdGFiYXNlOiAoZGF0YWJhc2VVUkw/OiBzdHJpbmcpID0+IGRhdGFiYXNlLkRhdGFiYXNlO1xuICBtZXNzYWdpbmc6ICgpID0+IG1lc3NhZ2luZy5NZXNzYWdpbmc7XG4gIHBlcmZvcm1hbmNlOiAoKSA9PiBwZXJmb3JtYW5jZS5QZXJmb3JtYW5jZTtcbiAgc3RvcmFnZTogKHN0b3JhZ2VCdWNrZXQ/OiBzdHJpbmcpID0+IHN0b3JhZ2UuU3RvcmFnZTtcbiAgZGVsZXRlOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBmaXJlc3RvcmU6ICgpID0+IGZpcmVzdG9yZS5GaXJlc3RvcmU7XG4gIGZ1bmN0aW9uczogKHJlZ2lvbj86IHN0cmluZykgPT4gZnVuY3Rpb25zLkZ1bmN0aW9ucztcbiAgcmVtb3RlQ29uZmlnOiAoKSA9PiByZW1vdGVDb25maWcuUmVtb3RlQ29uZmlnO1xufVxuXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IG5ldyBWZXJzaW9uKCdBTkdVTEFSRklSRTJfVkVSU0lPTicpO1xuXG5leHBvcnQgZnVuY3Rpb24gybVmaXJlYmFzZUFwcEZhY3Rvcnkob3B0aW9uczogRmlyZWJhc2VPcHRpb25zLCB6b25lOiBOZ1pvbmUsIG5hbWVPckNvbmZpZz86IHN0cmluZyB8IEZpcmViYXNlQXBwQ29uZmlnIHwgbnVsbCkge1xuICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPckNvbmZpZyA9PT0gJ3N0cmluZycgJiYgbmFtZU9yQ29uZmlnIHx8ICdbREVGQVVMVF0nO1xuICBjb25zdCBjb25maWcgPSB0eXBlb2YgbmFtZU9yQ29uZmlnID09PSAnb2JqZWN0JyAmJiBuYW1lT3JDb25maWcgfHwge307XG4gIGNvbmZpZy5uYW1lID0gY29uZmlnLm5hbWUgfHwgbmFtZTtcbiAgLy8gQWRkZWQgYW55IGR1ZSB0byBzb21lIGluY29uc2lzdGVuY3kgYmV0d2VlbiBAZmlyZWJhc2UvYXBwIGFuZCBmaXJlYmFzZSB0eXBlc1xuICBjb25zdCBleGlzdGluZ0FwcCA9IGZpcmViYXNlLmFwcHMuZmlsdGVyKGFwcCA9PiBhcHAgJiYgYXBwLm5hbWUgPT09IGNvbmZpZy5uYW1lKVswXSBhcyBhbnk7XG4gIC8vIFdlIHN1cHBvcnQgRmlyZWJhc2VDb25maWcsIGluaXRpYWxpemVBcHAncyBwdWJsaWMgdHlwZSBvbmx5IGFjY2VwdHMgc3RyaW5nOyBuZWVkIHRvIGNhc3QgYXMgYW55XG4gIC8vIENvdWxkIGJlIHNvbHZlZCB3aXRoIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvcHVsbC8xMjA2XG4gIHJldHVybiAoZXhpc3RpbmdBcHAgfHwgem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBmaXJlYmFzZS5pbml0aWFsaXplQXBwKG9wdGlvbnMsIGNvbmZpZyBhcyBhbnkpKSkgYXMgRmlyZWJhc2VBcHA7XG59XG5cbmNvbnN0IEZJUkVCQVNFX0FQUF9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogRmlyZWJhc2VBcHAsXG4gIHVzZUZhY3Rvcnk6IMm1ZmlyZWJhc2VBcHBGYWN0b3J5LFxuICBkZXBzOiBbXG4gICAgRklSRUJBU0VfT1BUSU9OUyxcbiAgICBOZ1pvbmUsXG4gICAgW25ldyBPcHRpb25hbCgpLCBGSVJFQkFTRV9BUFBfTkFNRV1cbiAgXVxufTtcblxuQE5nTW9kdWxlKHtcbiAgcHJvdmlkZXJzOiBbRklSRUJBU0VfQVBQX1BST1ZJREVSXVxufSlcbmV4cG9ydCBjbGFzcyBBbmd1bGFyRmlyZU1vZHVsZSB7XG4gIHN0YXRpYyBpbml0aWFsaXplQXBwKG9wdGlvbnM6IEZpcmViYXNlT3B0aW9ucywgbmFtZU9yQ29uZmlnPzogc3RyaW5nIHwgRmlyZWJhc2VBcHBDb25maWcpOiBNb2R1bGVXaXRoUHJvdmlkZXJzPEFuZ3VsYXJGaXJlTW9kdWxlPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5nTW9kdWxlOiBBbmd1bGFyRmlyZU1vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogRklSRUJBU0VfT1BUSU9OUywgdXNlVmFsdWU6IG9wdGlvbnN9LFxuICAgICAgICB7cHJvdmlkZTogRklSRUJBU0VfQVBQX05BTUUsIHVzZVZhbHVlOiBuYW1lT3JDb25maWd9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpiYW4tdHlwZXNcbiAgY29uc3RydWN0b3IoQEluamVjdChQTEFURk9STV9JRCkgcGxhdGZvcm1JZDogT2JqZWN0KSB7XG4gICAgZmlyZWJhc2UucmVnaXN0ZXJWZXJzaW9uKCdhbmd1bGFyZmlyZScsIFZFUlNJT04uZnVsbCwgcGxhdGZvcm1JZC50b1N0cmluZygpKTtcbiAgICBmaXJlYmFzZS5yZWdpc3RlclZlcnNpb24oJ2FuZ3VsYXInLCBOR19WRVJTSU9OLmZ1bGwpO1xuICB9XG59XG4iXX0=