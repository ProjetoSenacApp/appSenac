/**
 * @fileoverview added by tsickle
 * Generated from: firestore.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID } from '@angular/core';
import { from, of } from 'rxjs';
import { AngularFirestoreDocument } from './document/document';
import { AngularFirestoreCollection } from './collection/collection';
import { AngularFirestoreCollectionGroup } from './collection-group/collection-group';
import { FIREBASE_APP_NAME, FIREBASE_OPTIONS, ɵAngularFireSchedulers, ɵfirebaseAppFactory, ɵkeepUnstableUntilFirstFactory } from '@angular/fire';
import { isPlatformServer } from '@angular/common';
import 'firebase/firestore';
import * as i0 from "@angular/core";
import * as i1 from "@angular/fire";
/** @type {?} */
const atFirestore = require('@firebase/firestore');
import firebase from 'firebase/app';
/**
 * The value of this token determines whether or not the firestore will have persistance enabled
 * @type {?}
 */
export const ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');
/** @type {?} */
export const PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');
/** @type {?} */
export const SETTINGS = new InjectionToken('angularfire2.firestore.settings');
/**
 * A utility methods for associating a collection reference with
 * a query.
 *
 * @param {?} collectionRef - A collection reference to query
 * @param {?=} queryFn - The callback to create a query
 *
 * Example:
 * const { query, ref } = associateQuery(docRef.collection('items'), ref => {
 *  return ref.where('age', '<', 200);
 * });
 * @return {?}
 */
export function associateQuery(collectionRef, queryFn = (/**
 * @param {?} ref
 * @return {?}
 */
ref => ref)) {
    /** @type {?} */
    const query = queryFn(collectionRef);
    /** @type {?} */
    const ref = collectionRef;
    return { query, ref };
}
/**
 * AngularFirestore Service
 *
 * This service is the main entry point for this feature module. It provides
 * an API for creating Collection and Reference services. These services can
 * then be used to do data updates and observable streams of the data.
 *
 * Example:
 *
 * import { Component } from '\@angular/core';
 * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '\@angular/fire/firestore';
 * import { Observable } from 'rxjs/Observable';
 * import { from } from 'rxjs/observable';
 *
 * \@Component({
 *   selector: 'app-my-component',
 *   template: `
 *    <h2>Items for {{ (profile | async)?.name }}
 *    <ul>
 *       <li *ngFor="let item of items | async">{{ item.name }}</li>
 *    </ul>
 *    <div class="control-input">
 *       <input type="text" #itemname />
 *       <button (click)="addItem(itemname.value)">Add Item</button>
 *    </div>
 *   `
 * })
 * export class MyComponent implements OnInit {
 *
 *   // services for data operations and data streaming
 *   private readonly itemsRef: AngularFirestoreCollection<Item>;
 *   private readonly profileRef: AngularFirestoreDocument<Profile>;
 *
 *   // observables for template
 *   items: Observable<Item[]>;
 *   profile: Observable<Profile>;
 *
 *   // inject main service
 *   constructor(private readonly afs: AngularFirestore) {}
 *
 *   ngOnInit() {
 *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));
 *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));
 *     // this.items = from(this.itemsRef); // you can also do this with no mapping
 *
 *     this.profileRef = afs.doc('users/davideast');
 *     this.profile = this.profileRef.valueChanges();
 *   }
 *
 *   addItem(name: string) {
 *     const user = 'davideast';
 *     this.itemsRef.add({ name, user });
 *   }
 * }
 */
export class AngularFirestore {
    /**
     * Each Feature of AngularFire has a FirebaseApp injected. This way we
     * don't rely on the main Firebase App instance and we can create named
     * apps and use multiple apps.
     * @param {?} options
     * @param {?} nameOrConfig
     * @param {?} shouldEnablePersistence
     * @param {?} settings
     * @param {?} platformId
     * @param {?} zone
     * @param {?} persistenceSettings
     */
    constructor(options, nameOrConfig, shouldEnablePersistence, settings, 
    // tslint:disable-next-line:ban-types
    platformId, zone, persistenceSettings) {
        this.schedulers = new ɵAngularFireSchedulers(zone);
        this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);
        this.firestore = zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);
            // INVESTIGATE this seems to be required because in the browser build registerFirestore is an Object?
            //             seems like we're fighting ngcc. In the server firestore() isn't available, so I have to register
            //             in the browser registerFirestore is not a function... maybe this is an underlying firebase-js-sdk issue
            if ('registerFirestore' in atFirestore) {
                ((/** @type {?} */ (atFirestore))).registerFirestore((/** @type {?} */ (firebase)));
            }
            /** @type {?} */
            const firestore = app.firestore();
            if (settings) {
                firestore.settings(settings);
            }
            return firestore;
        }));
        if (shouldEnablePersistence && !isPlatformServer(platformId)) {
            // We need to try/catch here because not all enablePersistence() failures are caught
            // https://github.com/firebase/firebase-js-sdk/issues/608
            /** @type {?} */
            const enablePersistence = (/**
             * @return {?}
             */
            () => {
                try {
                    return from(this.firestore.enablePersistence(persistenceSettings || undefined).then((/**
                     * @return {?}
                     */
                    () => true), (/**
                     * @return {?}
                     */
                    () => false)));
                }
                catch (e) {
                    return of(false);
                }
            });
            this.persistenceEnabled$ = zone.runOutsideAngular(enablePersistence);
        }
        else {
            this.persistenceEnabled$ = of(false);
        }
    }
    /**
     * @template T
     * @param {?} pathOrRef
     * @param {?=} queryFn
     * @return {?}
     */
    collection(pathOrRef, queryFn) {
        /** @type {?} */
        let collectionRef;
        if (typeof pathOrRef === 'string') {
            collectionRef = this.firestore.collection(pathOrRef);
        }
        else {
            collectionRef = pathOrRef;
        }
        const { ref, query } = associateQuery(collectionRef, queryFn);
        /** @type {?} */
        const refInZone = this.schedulers.ngZone.run((/**
         * @return {?}
         */
        () => ref));
        return new AngularFirestoreCollection(refInZone, query, this);
    }
    /**
     * Create a reference to a Firestore Collection Group based on a collectionId
     * and an optional query function to narrow the result
     * set.
     * @template T
     * @param {?} collectionId
     * @param {?=} queryGroupFn
     * @return {?}
     */
    collectionGroup(collectionId, queryGroupFn) {
        /** @type {?} */
        const queryFn = queryGroupFn || ((/**
         * @param {?} ref
         * @return {?}
         */
        ref => ref));
        /** @type {?} */
        const collectionGroup = this.firestore.collectionGroup(collectionId);
        return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);
    }
    /**
     * @template T
     * @param {?} pathOrRef
     * @return {?}
     */
    doc(pathOrRef) {
        /** @type {?} */
        let ref;
        if (typeof pathOrRef === 'string') {
            ref = this.firestore.doc(pathOrRef);
        }
        else {
            ref = pathOrRef;
        }
        /** @type {?} */
        const refInZone = this.schedulers.ngZone.run((/**
         * @return {?}
         */
        () => ref));
        return new AngularFirestoreDocument(refInZone, this);
    }
    /**
     * Returns a generated Firestore Document Id.
     * @return {?}
     */
    createId() {
        return this.firestore.collection('_').doc().id;
    }
}
AngularFirestore.decorators = [
    { type: Injectable, args: [{
                providedIn: 'any'
            },] }
];
/** @nocollapse */
AngularFirestore.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [FIREBASE_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FIREBASE_APP_NAME,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ENABLE_PERSISTENCE,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SETTINGS,] }] },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [PERSISTENCE_SETTINGS,] }] }
];
/** @nocollapse */ AngularFirestore.ɵprov = i0.ɵɵdefineInjectable({ factory: function AngularFirestore_Factory() { return new AngularFirestore(i0.ɵɵinject(i1.FIREBASE_OPTIONS), i0.ɵɵinject(i1.FIREBASE_APP_NAME, 8), i0.ɵɵinject(ENABLE_PERSISTENCE, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PERSISTENCE_SETTINGS, 8)); }, token: AngularFirestore, providedIn: "any" });
if (false) {
    /** @type {?} */
    AngularFirestore.prototype.firestore;
    /** @type {?} */
    AngularFirestore.prototype.persistenceEnabled$;
    /** @type {?} */
    AngularFirestore.prototype.schedulers;
    /** @type {?} */
    AngularFirestore.prototype.keepUnstableUntilFirst;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlyZXN0b3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2ZpcmVzdG9yZS9maXJlc3RvcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEcsT0FBTyxFQUFFLElBQUksRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFXNUMsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDL0QsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDckUsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDdEYsT0FBTyxFQUNMLGlCQUFpQixFQUNqQixnQkFBZ0IsRUFHaEIsc0JBQXNCLEVBQ3RCLG1CQUFtQixFQUNuQiw4QkFBOEIsRUFDL0IsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFbkQsT0FBTyxvQkFBb0IsQ0FBQzs7OztNQUN0QixXQUFXLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDO0FBQ2xELE9BQU8sUUFBUSxNQUFNLGNBQWMsQ0FBQzs7Ozs7QUFLcEMsTUFBTSxPQUFPLGtCQUFrQixHQUFHLElBQUksY0FBYyxDQUFVLHlDQUF5QyxDQUFDOztBQUN4RyxNQUFNLE9BQU8sb0JBQW9CLEdBQUcsSUFBSSxjQUFjLENBQWtDLDRDQUE0QyxDQUFDOztBQUNySSxNQUFNLE9BQU8sUUFBUSxHQUFHLElBQUksY0FBYyxDQUFXLGlDQUFpQyxDQUFDOzs7Ozs7Ozs7Ozs7OztBQWN2RixNQUFNLFVBQVUsY0FBYyxDQUFDLGFBQWtDLEVBQUUsT0FBTzs7OztBQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FB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LCtDQUF5RDs7SUFDekQsc0NBQW1EOztJQUNuRCxrREFBaUYiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBOZ1pvbmUsIE9wdGlvbmFsLCBQTEFURk9STV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbSwgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIEFzc29jaWF0ZWRSZWZlcmVuY2UsXG4gIENvbGxlY3Rpb25SZWZlcmVuY2UsXG4gIERvY3VtZW50UmVmZXJlbmNlLFxuICBQZXJzaXN0ZW5jZVNldHRpbmdzLFxuICBRdWVyeSxcbiAgUXVlcnlGbixcbiAgUXVlcnlHcm91cEZuLFxuICBTZXR0aW5nc1xufSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQW5ndWxhckZpcmVzdG9yZURvY3VtZW50IH0gZnJvbSAnLi9kb2N1bWVudC9kb2N1bWVudCc7XG5pbXBvcnQgeyBBbmd1bGFyRmlyZXN0b3JlQ29sbGVjdGlvbiB9IGZyb20gJy4vY29sbGVjdGlvbi9jb2xsZWN0aW9uJztcbmltcG9ydCB7IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uR3JvdXAgfSBmcm9tICcuL2NvbGxlY3Rpb24tZ3JvdXAvY29sbGVjdGlvbi1ncm91cCc7XG5pbXBvcnQge1xuICBGSVJFQkFTRV9BUFBfTkFNRSxcbiAgRklSRUJBU0VfT1BUSU9OUyxcbiAgRmlyZWJhc2VBcHBDb25maWcsXG4gIEZpcmViYXNlT3B0aW9ucyxcbiAgybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMsXG4gIMm1ZmlyZWJhc2VBcHBGYWN0b3J5LFxuICDJtWtlZXBVbnN0YWJsZVVudGlsRmlyc3RGYWN0b3J5XG59IGZyb20gJ0Bhbmd1bGFyL2ZpcmUnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybVNlcnZlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBmaXJlc3RvcmUgfSBmcm9tICdmaXJlYmFzZS9hcHAnO1xuaW1wb3J0ICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuY29uc3QgYXRGaXJlc3RvcmUgPSByZXF1aXJlKCdAZmlyZWJhc2UvZmlyZXN0b3JlJyk7XG5pbXBvcnQgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UvYXBwJztcblxuLyoqXG4gKiBUaGUgdmFsdWUgb2YgdGhpcyB0b2tlbiBkZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBmaXJlc3RvcmUgd2lsbCBoYXZlIHBlcnNpc3RhbmNlIGVuYWJsZWRcbiAqL1xuZXhwb3J0IGNvbnN0IEVOQUJMRV9QRVJTSVNURU5DRSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxib29sZWFuPignYW5ndWxhcmZpcmUyLmVuYWJsZUZpcmVzdG9yZVBlcnNpc3RlbmNlJyk7XG5leHBvcnQgY29uc3QgUEVSU0lTVEVOQ0VfU0VUVElOR1MgPSBuZXcgSW5qZWN0aW9uVG9rZW48UGVyc2lzdGVuY2VTZXR0aW5ncyB8IHVuZGVmaW5lZD4oJ2FuZ3VsYXJmaXJlMi5maXJlc3RvcmUucGVyc2lzdGVuY2VTZXR0aW5ncycpO1xuZXhwb3J0IGNvbnN0IFNFVFRJTkdTID0gbmV3IEluamVjdGlvblRva2VuPFNldHRpbmdzPignYW5ndWxhcmZpcmUyLmZpcmVzdG9yZS5zZXR0aW5ncycpO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBtZXRob2RzIGZvciBhc3NvY2lhdGluZyBhIGNvbGxlY3Rpb24gcmVmZXJlbmNlIHdpdGhcbiAqIGEgcXVlcnkuXG4gKlxuICogQHBhcmFtIGNvbGxlY3Rpb25SZWYgLSBBIGNvbGxlY3Rpb24gcmVmZXJlbmNlIHRvIHF1ZXJ5XG4gKiBAcGFyYW0gcXVlcnlGbiAtIFRoZSBjYWxsYmFjayB0byBjcmVhdGUgYSBxdWVyeVxuICpcbiAqIEV4YW1wbGU6XG4gKiBjb25zdCB7IHF1ZXJ5LCByZWYgfSA9IGFzc29jaWF0ZVF1ZXJ5KGRvY1JlZi5jb2xsZWN0aW9uKCdpdGVtcycpLCByZWYgPT4ge1xuICogIHJldHVybiByZWYud2hlcmUoJ2FnZScsICc8JywgMjAwKTtcbiAqIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzb2NpYXRlUXVlcnkoY29sbGVjdGlvblJlZjogQ29sbGVjdGlvblJlZmVyZW5jZSwgcXVlcnlGbiA9IHJlZiA9PiByZWYpOiBBc3NvY2lhdGVkUmVmZXJlbmNlIHtcbiAgY29uc3QgcXVlcnkgPSBxdWVyeUZuKGNvbGxlY3Rpb25SZWYpO1xuICBjb25zdCByZWYgPSBjb2xsZWN0aW9uUmVmO1xuICByZXR1cm4geyBxdWVyeSwgcmVmIH07XG59XG5cbi8qKlxuICogQW5ndWxhckZpcmVzdG9yZSBTZXJ2aWNlXG4gKlxuICogVGhpcyBzZXJ2aWNlIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IGZvciB0aGlzIGZlYXR1cmUgbW9kdWxlLiBJdCBwcm92aWRlc1xuICogYW4gQVBJIGZvciBjcmVhdGluZyBDb2xsZWN0aW9uIGFuZCBSZWZlcmVuY2Ugc2VydmljZXMuIFRoZXNlIHNlcnZpY2VzIGNhblxuICogdGhlbiBiZSB1c2VkIHRvIGRvIGRhdGEgdXBkYXRlcyBhbmQgb2JzZXJ2YWJsZSBzdHJlYW1zIG9mIHRoZSBkYXRhLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQgeyBBbmd1bGFyRmlyZXN0b3JlLCBBbmd1bGFyRmlyZXN0b3JlQ29sbGVjdGlvbiwgQW5ndWxhckZpcmVzdG9yZURvY3VtZW50IH0gZnJvbSAnQGFuZ3VsYXIvZmlyZS9maXJlc3RvcmUnO1xuICogaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG4gKiBpbXBvcnQgeyBmcm9tIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdhcHAtbXktY29tcG9uZW50JyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgIDxoMj5JdGVtcyBmb3Ige3sgKHByb2ZpbGUgfCBhc3luYyk/Lm5hbWUgfX1cbiAqICAgIDx1bD5cbiAqICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtcyB8IGFzeW5jXCI+e3sgaXRlbS5uYW1lIH19PC9saT5cbiAqICAgIDwvdWw+XG4gKiAgICA8ZGl2IGNsYXNzPVwiY29udHJvbC1pbnB1dFwiPlxuICogICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgI2l0ZW1uYW1lIC8+XG4gKiAgICAgICA8YnV0dG9uIChjbGljayk9XCJhZGRJdGVtKGl0ZW1uYW1lLnZhbHVlKVwiPkFkZCBJdGVtPC9idXR0b24+XG4gKiAgICA8L2Rpdj5cbiAqICAgYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gKlxuICogICAvLyBzZXJ2aWNlcyBmb3IgZGF0YSBvcGVyYXRpb25zIGFuZCBkYXRhIHN0cmVhbWluZ1xuICogICBwcml2YXRlIHJlYWRvbmx5IGl0ZW1zUmVmOiBBbmd1bGFyRmlyZXN0b3JlQ29sbGVjdGlvbjxJdGVtPjtcbiAqICAgcHJpdmF0ZSByZWFkb25seSBwcm9maWxlUmVmOiBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8UHJvZmlsZT47XG4gKlxuICogICAvLyBvYnNlcnZhYmxlcyBmb3IgdGVtcGxhdGVcbiAqICAgaXRlbXM6IE9ic2VydmFibGU8SXRlbVtdPjtcbiAqICAgcHJvZmlsZTogT2JzZXJ2YWJsZTxQcm9maWxlPjtcbiAqXG4gKiAgIC8vIGluamVjdCBtYWluIHNlcnZpY2VcbiAqICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBhZnM6IEFuZ3VsYXJGaXJlc3RvcmUpIHt9XG4gKlxuICogICBuZ09uSW5pdCgpIHtcbiAqICAgICB0aGlzLml0ZW1zUmVmID0gYWZzLmNvbGxlY3Rpb24oJ2l0ZW1zJywgcmVmID0+IHJlZi53aGVyZSgndXNlcicsICc9PScsICdkYXZpZGVhc3QnKS5saW1pdCgxMCkpO1xuICogICAgIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zUmVmLnZhbHVlQ2hhbmdlcygpLm1hcChzbmFwID0+IHNuYXAuZG9jcy5tYXAoZGF0YSA9PiBkb2MuZGF0YSgpKSk7XG4gKiAgICAgLy8gdGhpcy5pdGVtcyA9IGZyb20odGhpcy5pdGVtc1JlZik7IC8vIHlvdSBjYW4gYWxzbyBkbyB0aGlzIHdpdGggbm8gbWFwcGluZ1xuICpcbiAqICAgICB0aGlzLnByb2ZpbGVSZWYgPSBhZnMuZG9jKCd1c2Vycy9kYXZpZGVhc3QnKTtcbiAqICAgICB0aGlzLnByb2ZpbGUgPSB0aGlzLnByb2ZpbGVSZWYudmFsdWVDaGFuZ2VzKCk7XG4gKiAgIH1cbiAqXG4gKiAgIGFkZEl0ZW0obmFtZTogc3RyaW5nKSB7XG4gKiAgICAgY29uc3QgdXNlciA9ICdkYXZpZGVhc3QnO1xuICogICAgIHRoaXMuaXRlbXNSZWYuYWRkKHsgbmFtZSwgdXNlciB9KTtcbiAqICAgfVxuICogfVxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdhbnknXG59KVxuZXhwb3J0IGNsYXNzIEFuZ3VsYXJGaXJlc3RvcmUge1xuICBwdWJsaWMgcmVhZG9ubHkgZmlyZXN0b3JlOiBmaXJlc3RvcmUuRmlyZXN0b3JlO1xuICBwdWJsaWMgcmVhZG9ubHkgcGVyc2lzdGVuY2VFbmFibGVkJDogT2JzZXJ2YWJsZTxib29sZWFuPjtcbiAgcHVibGljIHJlYWRvbmx5IHNjaGVkdWxlcnM6IMm1QW5ndWxhckZpcmVTY2hlZHVsZXJzO1xuICBwdWJsaWMgcmVhZG9ubHkga2VlcFVuc3RhYmxlVW50aWxGaXJzdDogPFQ+KG9iczogT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZTxUPjtcblxuICAvKipcbiAgICogRWFjaCBGZWF0dXJlIG9mIEFuZ3VsYXJGaXJlIGhhcyBhIEZpcmViYXNlQXBwIGluamVjdGVkLiBUaGlzIHdheSB3ZVxuICAgKiBkb24ndCByZWx5IG9uIHRoZSBtYWluIEZpcmViYXNlIEFwcCBpbnN0YW5jZSBhbmQgd2UgY2FuIGNyZWF0ZSBuYW1lZFxuICAgKiBhcHBzIGFuZCB1c2UgbXVsdGlwbGUgYXBwcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoRklSRUJBU0VfT1BUSU9OUykgb3B0aW9uczogRmlyZWJhc2VPcHRpb25zLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRklSRUJBU0VfQVBQX05BTUUpIG5hbWVPckNvbmZpZzogc3RyaW5nIHwgRmlyZWJhc2VBcHBDb25maWcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRU5BQkxFX1BFUlNJU1RFTkNFKSBzaG91bGRFbmFibGVQZXJzaXN0ZW5jZTogYm9vbGVhbiB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChTRVRUSU5HUykgc2V0dGluZ3M6IFNldHRpbmdzIHwgbnVsbCxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6YmFuLXR5cGVzXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgIHpvbmU6IE5nWm9uZSxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFBFUlNJU1RFTkNFX1NFVFRJTkdTKSBwZXJzaXN0ZW5jZVNldHRpbmdzOiBQZXJzaXN0ZW5jZVNldHRpbmdzIHwgbnVsbFxuICApIHtcbiAgICB0aGlzLnNjaGVkdWxlcnMgPSBuZXcgybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMoem9uZSk7XG4gICAgdGhpcy5rZWVwVW5zdGFibGVVbnRpbEZpcnN0ID0gybVrZWVwVW5zdGFibGVVbnRpbEZpcnN0RmFjdG9yeSh0aGlzLnNjaGVkdWxlcnMpO1xuXG4gICAgdGhpcy5maXJlc3RvcmUgPSB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgIGNvbnN0IGFwcCA9IMm1ZmlyZWJhc2VBcHBGYWN0b3J5KG9wdGlvbnMsIHpvbmUsIG5hbWVPckNvbmZpZyk7XG4gICAgICAvLyBJTlZFU1RJR0FURSB0aGlzIHNlZW1zIHRvIGJlIHJlcXVpcmVkIGJlY2F1c2UgaW4gdGhlIGJyb3dzZXIgYnVpbGQgcmVnaXN0ZXJGaXJlc3RvcmUgaXMgYW4gT2JqZWN0P1xuICAgICAgLy8gICAgICAgICAgICAgc2VlbXMgbGlrZSB3ZSdyZSBmaWdodGluZyBuZ2NjLiBJbiB0aGUgc2VydmVyIGZpcmVzdG9yZSgpIGlzbid0IGF2YWlsYWJsZSwgc28gSSBoYXZlIHRvIHJlZ2lzdGVyXG4gICAgICAvLyAgICAgICAgICAgICBpbiB0aGUgYnJvd3NlciByZWdpc3RlckZpcmVzdG9yZSBpcyBub3QgYSBmdW5jdGlvbi4uLiBtYXliZSB0aGlzIGlzIGFuIHVuZGVybHlpbmcgZmlyZWJhc2UtanMtc2RrIGlzc3VlXG4gICAgICBpZiAoJ3JlZ2lzdGVyRmlyZXN0b3JlJyBpbiBhdEZpcmVzdG9yZSkge1xuICAgICAgICAoYXRGaXJlc3RvcmUgYXMgYW55KS5yZWdpc3RlckZpcmVzdG9yZShmaXJlYmFzZSBhcyBhbnkpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlyZXN0b3JlID0gYXBwLmZpcmVzdG9yZSgpO1xuICAgICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICAgIGZpcmVzdG9yZS5zZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyZXN0b3JlO1xuICAgIH0pO1xuXG4gICAgaWYgKHNob3VsZEVuYWJsZVBlcnNpc3RlbmNlICYmICFpc1BsYXRmb3JtU2VydmVyKHBsYXRmb3JtSWQpKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHRyeS9jYXRjaCBoZXJlIGJlY2F1c2Ugbm90IGFsbCBlbmFibGVQZXJzaXN0ZW5jZSgpIGZhaWx1cmVzIGFyZSBjYXVnaHRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzYwOFxuICAgICAgY29uc3QgZW5hYmxlUGVyc2lzdGVuY2UgPSAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZyb20odGhpcy5maXJlc3RvcmUuZW5hYmxlUGVyc2lzdGVuY2UocGVyc2lzdGVuY2VTZXR0aW5ncyB8fCB1bmRlZmluZWQpLnRoZW4oKCkgPT4gdHJ1ZSwgKCkgPT4gZmFsc2UpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBvZihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnBlcnNpc3RlbmNlRW5hYmxlZCQgPSB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKGVuYWJsZVBlcnNpc3RlbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wZXJzaXN0ZW5jZUVuYWJsZWQkID0gb2YoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByZWZlcmVuY2UgdG8gYSBGaXJlc3RvcmUgQ29sbGVjdGlvbiBiYXNlZCBvbiBhIHBhdGggb3JcbiAgICogQ29sbGVjdGlvblJlZmVyZW5jZSBhbmQgYW4gb3B0aW9uYWwgcXVlcnkgZnVuY3Rpb24gdG8gbmFycm93IHRoZSByZXN1bHRcbiAgICogc2V0LlxuICAgKi9cbiAgY29sbGVjdGlvbjxUPihwYXRoOiBzdHJpbmcsIHF1ZXJ5Rm4/OiBRdWVyeUZuKTogQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb248VD47XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp1bmlmaWVkLXNpZ25hdHVyZXNcbiAgY29sbGVjdGlvbjxUPihyZWY6IENvbGxlY3Rpb25SZWZlcmVuY2UsIHF1ZXJ5Rm4/OiBRdWVyeUZuKTogQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb248VD47XG4gIGNvbGxlY3Rpb248VD4ocGF0aE9yUmVmOiBzdHJpbmcgfCBDb2xsZWN0aW9uUmVmZXJlbmNlLCBxdWVyeUZuPzogUXVlcnlGbik6IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uPFQ+IHtcbiAgICBsZXQgY29sbGVjdGlvblJlZjogQ29sbGVjdGlvblJlZmVyZW5jZTtcbiAgICBpZiAodHlwZW9mIHBhdGhPclJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbGxlY3Rpb25SZWYgPSB0aGlzLmZpcmVzdG9yZS5jb2xsZWN0aW9uKHBhdGhPclJlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbGxlY3Rpb25SZWYgPSBwYXRoT3JSZWY7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVmLCBxdWVyeSB9ID0gYXNzb2NpYXRlUXVlcnkoY29sbGVjdGlvblJlZiwgcXVlcnlGbik7XG4gICAgY29uc3QgcmVmSW5ab25lID0gdGhpcy5zY2hlZHVsZXJzLm5nWm9uZS5ydW4oKCkgPT4gcmVmKTtcbiAgICByZXR1cm4gbmV3IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uPFQ+KHJlZkluWm9uZSwgcXVlcnksIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlZmVyZW5jZSB0byBhIEZpcmVzdG9yZSBDb2xsZWN0aW9uIEdyb3VwIGJhc2VkIG9uIGEgY29sbGVjdGlvbklkXG4gICAqIGFuZCBhbiBvcHRpb25hbCBxdWVyeSBmdW5jdGlvbiB0byBuYXJyb3cgdGhlIHJlc3VsdFxuICAgKiBzZXQuXG4gICAqL1xuICBjb2xsZWN0aW9uR3JvdXA8VD4oY29sbGVjdGlvbklkOiBzdHJpbmcsIHF1ZXJ5R3JvdXBGbj86IFF1ZXJ5R3JvdXBGbik6IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uR3JvdXA8VD4ge1xuICAgIGNvbnN0IHF1ZXJ5Rm4gPSBxdWVyeUdyb3VwRm4gfHwgKHJlZiA9PiByZWYpO1xuICAgIGNvbnN0IGNvbGxlY3Rpb25Hcm91cDogUXVlcnkgPSB0aGlzLmZpcmVzdG9yZS5jb2xsZWN0aW9uR3JvdXAoY29sbGVjdGlvbklkKTtcbiAgICByZXR1cm4gbmV3IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uR3JvdXA8VD4ocXVlcnlGbihjb2xsZWN0aW9uR3JvdXApLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByZWZlcmVuY2UgdG8gYSBGaXJlc3RvcmUgRG9jdW1lbnQgYmFzZWQgb24gYSBwYXRoIG9yXG4gICAqIERvY3VtZW50UmVmZXJlbmNlLiBOb3RlIHRoYXQgZG9jdW1lbnRzIGFyZSBub3QgcXVlcnlhYmxlIGJlY2F1c2UgdGhleSBhcmVcbiAgICogc2ltcGx5IG9iamVjdHMuIEhvd2V2ZXIsIGRvY3VtZW50cyBoYXZlIHN1Yi1jb2xsZWN0aW9ucyB0aGF0IHJldHVybiBhXG4gICAqIENvbGxlY3Rpb24gcmVmZXJlbmNlIGFuZCBjYW4gYmUgcXVlcmllZC5cbiAgICovXG4gIGRvYzxUPihwYXRoOiBzdHJpbmcpOiBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8VD47XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp1bmlmaWVkLXNpZ25hdHVyZXNcbiAgZG9jPFQ+KHJlZjogRG9jdW1lbnRSZWZlcmVuY2UpOiBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8VD47XG4gIGRvYzxUPihwYXRoT3JSZWY6IHN0cmluZyB8IERvY3VtZW50UmVmZXJlbmNlKTogQW5ndWxhckZpcmVzdG9yZURvY3VtZW50PFQ+IHtcbiAgICBsZXQgcmVmOiBEb2N1bWVudFJlZmVyZW5jZTtcbiAgICBpZiAodHlwZW9mIHBhdGhPclJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlZiA9IHRoaXMuZmlyZXN0b3JlLmRvYyhwYXRoT3JSZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSBwYXRoT3JSZWY7XG4gICAgfVxuICAgIGNvbnN0IHJlZkluWm9uZSA9IHRoaXMuc2NoZWR1bGVycy5uZ1pvbmUucnVuKCgpID0+IHJlZik7XG4gICAgcmV0dXJuIG5ldyBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8VD4ocmVmSW5ab25lLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZ2VuZXJhdGVkIEZpcmVzdG9yZSBEb2N1bWVudCBJZC5cbiAgICovXG4gIGNyZWF0ZUlkKCkge1xuICAgIHJldHVybiB0aGlzLmZpcmVzdG9yZS5jb2xsZWN0aW9uKCdfJykuZG9jKCkuaWQ7XG4gIH1cbn1cbiJdfQ==