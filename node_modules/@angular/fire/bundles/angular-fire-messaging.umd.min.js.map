{"version":3,"sources":["../../../src/messaging/messaging.ts","../../../src/messaging/messaging.module.ts"],"names":["options","nameOrConfig","platformId","zone","_this","this","schedulers","ɵAngularFireSchedulers","messaging","of","undefined","pipe","subscribeOn","outsideAngular","observeOn","insideAngular","switchMap","isPlatformServer","EMPTY","import","map","ɵfirebaseAppFactory","app","shareReplay","bufferSize","refCount","requestPermission","firebase","isSupported","throwError","getToken","Notification","permission","defaultIfEmpty","tokenChanges","Observable","emitter","onTokenRefresh","next","error","complete","switchMapTo","concat","messages","onMessage","err","requestToken","catchError","mergeMap","deleteToken","token","ɵlazySDKProxy","Injectable","args","providedIn","Inject","FIREBASE_OPTIONS","Optional","type","FIREBASE_APP_NAME","Object","decorators","PLATFORM_ID","NgZone","NgModule","providers","AngularFireMessaging"],"mappings":"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","sourcesContent":["import { Inject, Injectable, NgZone, Optional, PLATFORM_ID } from '@angular/core';\nimport { messaging } from 'firebase/app';\nimport firebase from 'firebase/app';\nimport { concat, EMPTY, Observable, of, throwError, fromEvent } from 'rxjs';\nimport { catchError, defaultIfEmpty, map, mergeMap, observeOn, switchMap, switchMapTo, shareReplay, filter, subscribeOn } from 'rxjs/operators';\nimport {\n  FIREBASE_APP_NAME,\n  FIREBASE_OPTIONS,\n  FirebaseAppConfig,\n  FirebaseOptions,\n  ɵAngularFireSchedulers,\n  ɵfirebaseAppFactory,\n  ɵlazySDKProxy,\n  ɵPromiseProxy\n} from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\n\nexport interface AngularFireMessaging extends Omit<ɵPromiseProxy<messaging.Messaging>, 'deleteToken' | 'getToken' | 'requestPermission'> {\n}\n\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFireMessaging {\n\n  public readonly requestPermission: Observable<void>;\n  public readonly getToken: Observable<string | null>;\n  public readonly tokenChanges: Observable<string | null>;\n  public readonly messages: Observable<{}>;\n  public readonly requestToken: Observable<string | null>;\n  public readonly deleteToken: (token: string) => Observable<boolean>;\n\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options: FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) nameOrConfig: string | FirebaseAppConfig | null | undefined,\n    // tslint:disable-next-line:ban-types\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone\n  ) {\n    const schedulers = new ɵAngularFireSchedulers(zone);\n\n    const messaging = of(undefined).pipe(\n      subscribeOn(schedulers.outsideAngular),\n      observeOn(schedulers.insideAngular),\n      switchMap(() => isPlatformServer(platformId) ? EMPTY : import('firebase/messaging')),\n      map(() => ɵfirebaseAppFactory(options, zone, nameOrConfig)),\n      map(app => app.messaging()),\n      shareReplay({ bufferSize: 1, refCount: false })\n    );\n\n    this.requestPermission = messaging.pipe(\n      subscribeOn(schedulers.outsideAngular),\n      observeOn(schedulers.insideAngular),\n      // tslint:disable-next-line\n      switchMap(messaging => firebase.messaging.isSupported() ? messaging.requestPermission() : throwError('Not supported.'))\n    );\n\n    this.getToken = messaging.pipe(\n      subscribeOn(schedulers.outsideAngular),\n      observeOn(schedulers.insideAngular),\n      switchMap(messaging => firebase.messaging.isSupported() && Notification.permission === 'granted' ? messaging.getToken() : EMPTY),\n      defaultIfEmpty(null)\n    );\n\n    const tokenChanges = messaging.pipe(\n      subscribeOn(schedulers.outsideAngular),\n      observeOn(schedulers.insideAngular),\n      switchMap(messaging => firebase.messaging.isSupported() ? new Observable<string>(emitter =>\n        messaging.onTokenRefresh(emitter.next, emitter.error, emitter.complete)\n      ) : EMPTY),\n      switchMapTo(this.getToken)\n    );\n\n    this.tokenChanges = messaging.pipe(\n      subscribeOn(schedulers.outsideAngular),\n      observeOn(schedulers.insideAngular),\n      switchMap(messaging => firebase.messaging.isSupported() ? concat(this.getToken, tokenChanges) : EMPTY)\n    );\n\n\n    this.messages = messaging.pipe(\n      subscribeOn(schedulers.outsideAngular),\n      observeOn(schedulers.insideAngular),\n      switchMap(messaging => firebase.messaging.isSupported() ? new Observable<string>(emitter =>\n        messaging.onMessage(next => emitter.next(next), err => emitter.error(err), () => emitter.complete())\n      ) : EMPTY),\n    );\n\n    this.requestToken = of(undefined).pipe(\n      switchMap(() => this.requestPermission),\n      catchError(() => of(null)),\n      mergeMap(() => this.tokenChanges)\n    );\n\n    this.deleteToken = (token: string) => messaging.pipe(\n      subscribeOn(schedulers.outsideAngular),\n      observeOn(schedulers.insideAngular),\n      switchMap(messaging => messaging.deleteToken(token)),\n      defaultIfEmpty(false)\n    );\n\n    return ɵlazySDKProxy(this, messaging, zone);\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { AngularFireMessaging } from './messaging';\n\n@NgModule({\n  providers: [ AngularFireMessaging ]\n})\nexport class AngularFireMessagingModule { }\n"]}