/*

- Implement ALTER TABLE parsing.
- Compare two simulators and create ALTER TABLE/DROP TABLE queries.
- Implement CREATE INDEX.
- Implement the last bits of CREATE TABLE. E.g. the table constraints.
- Implement CREATE TYPE.

*/

const { escapeRegExp } = require('lodash');

class Simulator {
	constructor() {
		this.tables = {};
	}

	findByRegExp(regexp) {
		const result = regexp.exec(this.input);

		if (result) {
			const found = result[1];
			this.input = this.input.slice(found.length).replace(/^\s+/g, '');
			return found;
		}

		return null;
	}

	getToken(expectedTokens) {
		const result = this.findToken(expectedTokens);

		if (!result) {
			throw new Error(`Could not find one of token ${expectedTokens.join(', ')}.`);
		}

		return result;
	}

	findToken(expectedTokens) {
		const regexp = new RegExp(`^(${expectedTokens.map((token) => escapeRegExp(token)).join('|')})(\\b|\\s|$)`, 'i');
		return this.findByRegExp(regexp);
	}

	ifToken(expectedTokens, callback) {
		const token = this.findToken(expectedTokens);

		if (token) {
			callback(token);
			return true;
		}

		return false;
	}

	getUntil(excludeTokens) {
		console.log(`"${this.input}"`);
		const regexp = new RegExp(`^(.*?)\\s(:?!${excludeTokens.map((token) => escapeRegExp(token)).join('|')})`, 'i');

		console.log(regexp);

		const result =  this.findByRegExp(regexp);

		console.log(`Result: ${result}`);

		if (!result) {
			throw new Error();
		}

		return result;
	}

	getIdentifier() {
		console.log('Input:');
		console.log(this.input);

		const regexp = new RegExp('^([\\w\\._"]+)', 'i');
		const result = this.findByRegExp(regexp);

		if (!result) {
			throw new Error(`Unknown identifier.`);
		}

		return result;
	}

	getExpression() {
		const regexp = new RegExp('^([\\w\\._"\\(\\)]+)', 'i');
		const result = this.findByRegExp(regexp);

		if (!result) {
			throw new Error(`Unknown identifier.`);
		}

		console.log(`Test: ${result}`);

		return result;
	}

	scope(callback) {
		const openBracket = this.findToken(['(']);
		if (openBracket) {
			callback();

			this.getToken([')']);
		}
	}

	repeat(callback) {
		while (true) {
			const result = callback();

			if (!result) {
				break;
			}
		}
	}

	switchToken(map) {
		const expectedTokens = Object.keys(map);
		return this.ifToken(expectedTokens, (token) => {
			const callback = map[token];

			callback();
		});
	}

	simulateAlterTable() {
		this.getToken(['TABLE']);

		this.ifToken(['ALL IN TABLESPACE'], () => {
			const tableName = this.getIdentifier();

			this.ifToken(['OWNED BY'], () => {
				// TODO: Is there a repeat here?
				const roleName = this.getIdentifier();
			});

			this.getToken(['SET TABLESPACE']);

			const newTablespace = this.getIdentifier();

			this.ifToken(['NOWAIT'], () => {
				//
			});

			// FINISHED.
		});

		this.ifToken(['IF EXISTS'], () => {
			//
		});

		this.ifToken(['ONLY'], () => {

		});

		const tableName = this.getIdentifier();

		const found = this.switchToken({
			RENAME: () => {
				this.ifToken(['CONSTRAINT'], () => {
					const constraintName = this.getIdentifier();

					this.getToken(['TO']);

					const newConstraintName = this.getIdentifier();

					// TODO: Actually name the constraint with name. Are these constraints on columns, or
					// on tables?

					// FINISHED.
				});

				this.ifToken(['TO'], () => {
					const newTableName = this.getIdentifier();

					// TODO: Rename the table.

					// FINISHED.
				});
			},

			[`SET SCHEMA`]: () => {
				const newSchemaName = this.getIdentifier();

				// TODO: Set the schema name.

				// FINISHED.
			},
		});

		if (!found) {
			this.repeat(() => {
				this.switchToken({
					ADD: () => {
						this.ifToken(['COLUMN'], () => {

						});

						this.ifToken(['IF NOT EXISTS'], () => {

						});

						const found = this.ifToken(['CONSTRAINT', 'UNIQUE', 'PRIMARY KEY'], () => {
							// TODO: Add the constraint.
						});

						if (!found) {
							const column = this.getColumn();

							// TODO: Add column to table.
						}
					},

					DROP: () => {
						this.ifToken(['COLUMN'], () => {

						});

						this.ifToken(['IF NOT EXISTS'], () => {

						});

						const columnName = this.getIdentifier();

						this.ifToken(['RESTRICT', 'CASCADE'], () => {

						});
					},

					ALTER: () => {
						this.ifToken(['COLUMN'], () => {

						});

						const columnName = this.getIdentifier();

						this.switchToken({
							`SET DATA TYPE`: () => {

							},

							'TYPE': () => {

							},

							'SET DEFAULT': () => {

							},

							'DROP DEFAULT': () => {

							},

							'SET NOT NULL': () => {

							},

							'DROP NOT NULL': () => {

							},
						});
					},
				});

				return this.findToken([',']);
			});
		}
	}

	getColumn() {
		const column = {
			// TODO: The name may include the schema.
			name: this.getIdentifier(),

			// TODO: This this work without any constraint types?
			dataType: this.getUntil(['COLLATE', 'CONSTRAINT', 'NULL', 'NOT NULL', 'CHECK', 'DEFAULT', 'UNIQUE', 'PRIMARY KEY', 'REFERENCES', ',']),
			constraints: {},
		};

		this.ifToken(['COLLATE'], () => {
			column.collation = this.getIdentifier();
		});

		this.repeat(() => {
			const constraint = {
				name: null,
			};

			this.ifToken(['CONSTRAINT'], () => {
				constraint.name = this.getIdentifier();
			});

			const found = this.switchToken({
				[`NOT NULL`]: () => {
					column.constraints.notNull = constraint;
				},

				NULL: () => {
					column.constraints.null = constraint;
				},

				CHECK: () => {
					this.scope(() => {
						constraint.expression = this.getExpression();
					});

					this.ifToken(['NO INHERIT'], () => {
						constraint.noInherit = true;
					});

					column.constraints.check = constraint;
				},

				DEFAULT: () => {
					constraint.expression = this.getExpression();

					column.constraints.default = constraint;
				},

				UNIQUE: () => {
					this.ifToken(['WITH'], () => {
						this.scope(() => {
							constraint.parameters = [];

							this.repeat(() => {
								const storageParameter = this.getIdentifier();

								if (!this.ifToken(['='], () => {
									const storageValue = this.getIdentifier();

									constraint.parameters.push({
										key: storageParameter,
										value: storageValue,
									});
								})) {
									constraint.parameters.push({
										key: storageParameter,
										value: null,
									});
								}

								return this.findToken([',']);
							});
						});
					});

					this.ifToken(['USING INDEX TABLESPACE'], () => {
						constraint.tablespaceName = this.getIdentifier();
					});

					column.constraints.unique = constraint;
				},

				[`PRIMARY KEY`]: () => {
					this.ifToken(['WITH'], () => {
						this.scope(() => {
							constraint.parameters = [];

							this.repeat(() => {
								const storageParameter = this.getIdentifier();

								if (!this.ifToken(['='], () => {
									const storageValue = this.getIdentifier();

									constraint.parameters.push({
										key: storageParameter,
										value: storageValue,
									});
								})) {
									constraint.parameters.push({
										key: storageParameter,
										value: null,
									});
								}

								return this.findToken([',']);
							});
						});
					});

					this.ifToken(['USING INDEX TABLESPACE'], () => {
						constraint.tablespaceName = this.getIdentifier();
					});

					column.constraints.primaryKey = constraint;
				},

				REFERENCES: () => {
					constraint.referenceTableName = this.getIdentifier();

					this.scope(() => {
						constraint.referenceColumnName = this.getIdentifier();
					});

					this.ifToken(['MATCH'], () => {
						constraint.matchType = this.getToken(['FULL', 'PARTIAL', 'SIMPLE']);
					});

					this.ifToken(['ON DELETE'], () => {
						const actionType = this.getToken(['NO ACTION', 'RESTRICT', 'CASCADE', 'SET NULL', 'SET DEFAULT']);

						constraint.onDelete = actionType;
					});

					this.ifToken(['ON UPDATE'], () => {
						const actionType = this.getToken(['NO ACTION', 'RESTRICT', 'CASCADE', 'SET NULL', 'SET DEFAULT']);

						constraint.onUpdate = actionType;
					});

					column.constraints.references = constraint;
				},
			});

			if (found) {
				this.ifToken(['DEFERRABLE', 'NOT DEFERRABLE'], (defferable) => {
					constraint.defferable = defferable;
				});

				this.ifToken(['INITIALLY DEFERRED', 'INITIALLY IMMEDIATE'], (initially) => {
					constraint.initially = initially;
				});
			}

			return found;
		});

		return column;
	}

	simulateCreateTable() {
		const table = {
			name: null,
			columns: [],
		};

		// TODO: It's Global or local, temporary or temp, or unlogged.
		this.ifToken(['GLOBAL', 'LOCAL', 'TEMPORARY', 'TEMP', 'UNLOGGED'], (type) => {
			table.type = type;
		});

		this.getToken(['TABLE']);

		this.ifToken(['IF NOT EXISTS'], () => {
			table.ifNotExists = true;
		});

		table.name = this.getIdentifier();

		this.scope(() => {
			this.repeat(() => {
				const column = this.getColumn();

				table.columns.push(column);

				return this.findToken([',']);
			});
		});

		// TODO: Parse WITH, ON COMMIT, TABLESPACE
		// TODO: Parse table constraints.

		this.tables[table.name] = table;
	}

	simulateQuery(sql) {
		this.input = sql.replace(/^\s+/, '');

		const token = this.getToken(['CREATE', 'ALTER']);

		if (token === 'CREATE') {
			this.simulateCreateTable();
		}
		else if (token === 'ALTER') {
			this.simulateAlterTable();
		}
	}
}

const simulator = new Simulator();
simulator.simulateQuery(`CREATE TABLE accounts (
	id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
	created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	email CITEXT NOT NULL UNIQUE,
	first_name TEXT NOT NULL,
	last_name TEXT NOT NULL
)`);

console.log(JSON.stringify(simulator, null, 4));
