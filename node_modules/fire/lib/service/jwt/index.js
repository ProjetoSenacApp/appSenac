'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createToken = exports.getPayload = undefined;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var getPayload = exports.getPayload = function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(token) {
        var decoded;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        _context.next = 2;
                        return verify(token, {
                            // We specify which algrithms to allow explicitly.
                            algorithms: [algorithm],
                            // Just to be sure, we set a maxAge of 14 days.
                            maxAge: '14d'
                        });

                    case 2:
                        decoded = _context.sent;
                        return _context.abrupt('return', decoded);

                    case 4:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    }));

    return function getPayload(_x) {
        return _ref.apply(this, arguments);
    };
}();

var createToken = exports.createToken = function () {
    var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(payload) {
        var token;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        _context2.next = 2;
                        return sign(payload, {
                            algorithm: algorithm
                        });

                    case 2:
                        token = _context2.sent;
                        return _context2.abrupt('return', token);

                    case 4:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, _callee2, this);
    }));

    return function createToken(_x2) {
        return _ref2.apply(this, arguments);
    };
}();

var _jsonwebtoken = require('jsonwebtoken');

var _jsonwebtoken2 = _interopRequireDefault(_jsonwebtoken);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: Use a public key with a password stored in the env. Check
// https://github.com/auth0/node-jsonwebtoken/issues/139 on the exact options to use.
var secret = 'test';
var algorithm = 'HS512';

function verify(token, options) {
    return new _promise2.default(function (resolve, reject) {
        _jsonwebtoken2.default.verify(token, secret, options, function (error, decoded) {
            if (error) {
                reject(error);
            } else {
                resolve(decoded);
            }
        });
    });
}

function sign(payload, options) {
    return new _promise2.default(function (resolve, reject) {
        _jsonwebtoken2.default.sign(payload, secret, options, function (error, token) {
            if (error) {
                reject(error);
            } else {
                resolve(token);
            }
        });
    });
}