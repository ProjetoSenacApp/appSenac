"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _set = require("babel-runtime/core-js/set");

var _set2 = _interopRequireDefault(_set);

exports.default = function (context) {
    var classes = new _set2.default();
    var pluginName = "strip-classes";
    return {
        name: pluginName,
        manipulateOptions: function manipulateOptions(pluginOptions) {
            var plugins = pluginOptions.plugins.filter(function (_ref) {
                var _ref2 = (0, _slicedToArray3.default)(_ref, 1),
                    plugin = _ref2[0];

                return plugin && plugin.key === pluginName;
            });

            var _plugins$ = (0, _slicedToArray3.default)(plugins[0], 2),
                options = _plugins$[1];

            if (options && options.classes && Array.isArray(options.classes)) {
                options.classes.forEach(function (className) {
                    classes.add(className);
                });
            }
        },


        visitor: {
            ClassDeclaration: function ClassDeclaration(path) {
                if (path.node.seen) {
                    return;
                }

                var className = path.node.id.name;
                if (classes.has(className)) {
                    var methodNames = [];

                    path.traverse({
                        ClassMethod: function ClassMethod(classMethodPath) {
                            if (!classMethodPath.node.static) {
                                methodNames.push(classMethodPath.node.key.name);
                            }
                        },
                        ClassProperty: function ClassProperty(classPropertyPath) {
                            if (context.types.isFunction(classPropertyPath.node.value) && !classPropertyPath.node.value.static) {
                                methodNames.push(classPropertyPath.node.key.name);
                            }
                        }
                    });

                    var node = context.types.classDeclaration(path.node.id, path.node.superClass, context.types.classBody(methodNames.map(function (methodName) {
                        return context.types.classMethod("method", context.types.identifier(methodName), [], context.types.blockStatement([]));
                    })), path.node.decorators || []);
                    node.seen = true;
                    path.replaceWith(node);
                }
            }
        }
    };
};

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }