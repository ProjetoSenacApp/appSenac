'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _lodash = require('lodash');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Simulator = function () {
    function Simulator(simulator) {
        (0, _classCallCheck3.default)(this, Simulator);

        this.tables = {};
        this.types = {};
        this.input = null;

        if (simulator) {
            this.tables = (0, _lodash.cloneDeep)(simulator.tables);
            this.types = (0, _lodash.cloneDeep)(simulator.types);
        }
    }

    (0, _createClass3.default)(Simulator, [{
        key: 'toJSON',
        value: function toJSON() {
            return {
                tables: this.tables,
                types: this.types
            };
        }
    }, {
        key: 'findByRegExp',
        value: function findByRegExp(regexp) {
            var result = regexp.exec(this.input);

            if (result) {
                var found = result[1];
                this.input = this.input.slice(found.length).replace(/^\s*/g, '');
                return found;
            }

            return null;
        }
    }, {
        key: 'getToken',
        value: function getToken(expectedTokens) {
            var result = this.findToken(expectedTokens);

            if (!result) {
                throw new Error('Could not find one of token ' + expectedTokens.join(', ') + '.');
            }

            return result;
        }
    }, {
        key: 'findToken',
        value: function findToken(expectedTokens) {
            var regexp = new RegExp('^(' + expectedTokens.map(function (token) {
                return (0, _lodash.escapeRegExp)(token);
            }).join('|') + ')(\\b|\\s|$|,|\')', 'i');
            return this.findByRegExp(regexp);
        }
    }, {
        key: 'optionalToken',
        value: function optionalToken(expectedTokens) {
            var token = this.findToken(expectedTokens);

            return Boolean(token);
        }
    }, {
        key: 'ifToken',
        value: function ifToken(expectedTokens, ifCallback, elseCallback) {
            var token = this.findToken(expectedTokens);

            if (token) {
                ifCallback(token);

                return true;
            } else if (elseCallback) {
                elseCallback();
            }

            return false;
        }
    }, {
        key: 'getUntil',
        value: function getUntil(excludeTokens) {
            var regexp = new RegExp('^(.*?)\\s*(:?!' + excludeTokens.map(function (token) {
                return (0, _lodash.escapeRegExp)(token);
            }).join('|') + '|$)', 'i');
            var result = this.findByRegExp(regexp);

            if (!result) {
                throw new Error('Could not find one of ' + excludeTokens + '. Current input is ' + this.input);
            }

            return result;
        }
    }, {
        key: 'getIdentifier',
        value: function getIdentifier() {
            var regexp = new RegExp('^([\\w\\._"]+)', 'i');
            var result = this.findByRegExp(regexp);

            if (!result) {
                throw new Error('Unknown identifier.');
            }

            return result;
        }
    }, {
        key: 'getString',
        value: function getString() {
            var _this = this;

            (0, _assert2.default)(this.input[0] === '\'', 'Does not start with string opening \'.');

            var _loop = function _loop(i) {
                var isEscaped = function isEscaped() {
                    var search = i - 1;
                    var escaped = false;

                    while (search >= 0) {
                        var _character = _this.input[search];

                        if (_character === '\\') {
                            escaped = !escaped;
                        } else {
                            break;
                        }

                        search--;
                    }

                    return escaped;
                };

                var character = _this.input[i];

                if (character === '\'' && !isEscaped()) {
                    var found = _this.input.slice(1, i);
                    _this.input = _this.input.slice(found.length + 2).replace(/^\s*/g, '');
                    return {
                        v: found
                    };
                }
            };

            for (var i = 1; i < this.input.length; i++) {
                var _ret = _loop(i);

                if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
            }

            throw new Error('Could not find end of string character \'.');
        }
    }, {
        key: 'getInScope',
        value: function getInScope() {
            var _this2 = this;

            // We want to loop the input and keep track of strings etc.

            var state = {
                string: null,
                '{': 0,
                '(': 0,
                '[': 0
            };

            var closingBraces = {
                '}': '{',
                ')': '(',
                ']': '['
            };
            var openingBraces = (0, _keys2.default)(closingBraces).reduce(function (openingBraces, brace) {
                openingBraces[closingBraces[brace]] = brace;
                return openingBraces;
            }, {});

            var _loop2 = function _loop2(i) {
                var isEscaped = function isEscaped() {
                    var search = i - 1;
                    var escaped = false;

                    while (search >= 0) {
                        var _character2 = _this2.input[search];

                        if (_character2 === '\\') {
                            escaped = !escaped;
                        } else {
                            break;
                        }

                        search--;
                    }

                    return escaped;
                };

                var character = _this2.input[i];

                if (state.string !== null) {
                    if (character === state.string && !isEscaped()) {
                        state.string = null;
                    }
                } else if (character === ')' && state['{'] === 0 && state['['] === 0 && state['('] === 0 && !isEscaped()) {
                    var found = _this2.input.slice(0, i);

                    _this2.input = _this2.input.slice(found.length).replace(/^\s*/g, '');
                    return {
                        v: found
                    };
                } else if (character === '"' || character === '\'' || character === '`') {
                    state.string = character;
                } else if (closingBraces[character] && !isEscaped()) {
                    state[closingBraces[character]] -= 1;

                    if (state[closingBraces[character]] < 0) {
                        throw new Error('A ' + character + ' too many. There was no matching ' + closingBraces[character] + '.');
                    }
                } else if (openingBraces[character] && !isEscaped()) {
                    state[character] += 1;
                }
            };

            for (var i = 0; i < this.input.length; i++) {
                var _ret2 = _loop2(i);

                if ((typeof _ret2 === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret2)) === "object") return _ret2.v;
            }

            throw new Error('Could not find closing ).');
        }
    }, {
        key: 'getExpression',
        value: function getExpression() {
            var regexp = new RegExp('^([\\w\\._"\\(\\)]+)', 'i');
            var result = this.findByRegExp(regexp);

            if (!result) {
                throw new Error('Unknown identifier.');
            }

            return result;
        }
    }, {
        key: 'scope',
        value: function scope(callback) {
            var openBracket = this.findToken(['(']);

            if (openBracket) {
                var result = callback();

                this.getToken([')']);

                return result;
            }
        }
    }, {
        key: 'repeat',
        value: function repeat(callback) {
            while (true) {
                var result = callback();

                if (!result) {
                    break;
                }
            }
        }
    }, {
        key: 'switchToken',
        value: function switchToken(map) {
            var expectedTokens = (0, _keys2.default)(map);
            return this.ifToken(expectedTokens, function (token) {
                var callback = map[token];

                callback();
            });
        }
    }, {
        key: 'simulateDropType',
        value: function simulateDropType() {
            this.optionalToken(['IF EXISTS']);

            var typeName = this.getIdentifier();

            this.ifToken(['CASCADE', 'RESTRICT'], function () {
                //
            });

            if (this.types[typeName]) {
                delete this.types[typeName];
            }
        }
    }, {
        key: 'simulateDropTable',
        value: function simulateDropTable() {
            this.optionalToken(['IF EXISTS']);

            var tableName = this.getIdentifier();

            this.ifToken(['CASCADE', 'RESTRICT'], function () {
                //
            });

            if (this.tables[tableName]) {
                delete this.tables[tableName];
            }
        }
    }, {
        key: 'simulateAlterType',
        value: function simulateAlterType() {
            var _this3 = this;

            var typeName = this.getIdentifier();
            var type = this.types[typeName];

            this.getToken(['ADD']);
            this.getToken(['VALUE']);

            var newValue = this.getString();

            this.ifToken(['BEFORE', 'AFTER'], function (token) {
                var existingValue = _this3.getString();
                var index = type.labels.findIndex(function (label) {
                    return label === existingValue;
                });

                if (token.toUpperCase() === 'BEFORE') {
                    type.labels.splice(index, 0, newValue);
                } else {
                    type.labels.splice(index + 1, 0, newValue);
                }
            });
        }
    }, {
        key: 'simulateAlterTable',
        value: function simulateAlterTable() {
            var _this4 = this;

            this.ifToken(['ALL IN TABLESPACE'], function () {
                var tableName = _this4.getIdentifier();

                _this4.ifToken(['OWNED BY'], function () {
                    // TODO: Is there a repeat here?
                    var roleName = _this4.getIdentifier();
                });

                _this4.getToken(['SET TABLESPACE']);

                var newTablespace = _this4.getIdentifier();

                _this4.ifToken(['NOWAIT'], function () {
                    //
                });

                // FINISHED.
            });

            this.ifToken(['IF EXISTS'], function () {
                //
            });

            this.ifToken(['ONLY'], function () {});

            var tableName = this.getIdentifier();
            var table = this.tables[tableName];

            (0, _assert2.default)(table, 'Table ' + tableName + ' does not exist.');

            var found = this.switchToken((0, _defineProperty3.default)({
                RENAME: function RENAME() {
                    _this4.ifToken(['CONSTRAINT'], function () {
                        var constraintName = _this4.getIdentifier();

                        _this4.getToken(['TO']);

                        var newConstraintName = _this4.getIdentifier();

                        // TODO: rename to constraint.
                    }, function () {
                        _this4.ifToken(['TO'], function () {
                            var newTableName = _this4.getIdentifier();
                            table.name = newTableName;
                            _this4.tables[newTableName] = table;
                            delete _this4.tables[tableName];
                        }, function () {
                            _this4.optionalToken(['COLUMN']);

                            var columnName = _this4.getIdentifier();

                            _this4.getToken(['TO']);

                            var newColumnName = _this4.getIdentifier();

                            var table = _this4.tables[tableName];
                            var column = table.columns[columnName];
                            column.name = newColumnName;
                            table.columns[newColumnName] = column;
                            delete table.columns[columnName];
                        });
                    });
                }

            }, 'SET SCHEMA', function undefined() {
                var newSchemaName = _this4.getIdentifier();

                // TODO: Set the schema name. This also means we need to parse the schema from the
                // table name?
            }));

            if (!found) {
                this.repeat(function () {
                    _this4.switchToken({
                        'DROP CONSTRAINT': function DROPCONSTRAINT() {
                            var constraintName = _this4.getIdentifier();
                            var i = table.indexes.findIndex(function (index) {
                                return index.type === 'check' && index.name === constraintName;
                            });
                            table.indexes.splice(i, 1);
                        },

                        ADD: function ADD() {
                            _this4.optionalToken(['COLUMN']);

                            _this4.ifToken(['IF NOT EXISTS'], function () {
                                //
                            });

                            var _getColumn = _this4.getColumn(table),
                                column = _getColumn.column,
                                indexes = _getColumn.indexes;

                            if (column) {
                                table.columns[column.name] = column;
                            }

                            indexes.forEach(function (index) {
                                return _this4.addIndex(table, index);
                            });
                        },

                        DROP: function DROP() {
                            _this4.optionalToken(['COLUMN']);

                            _this4.ifToken(['IF NOT EXISTS'], function () {
                                //
                            });

                            var columnName = _this4.getIdentifier();

                            _this4.ifToken(['RESTRICT', 'CASCADE'], function () {});

                            delete _this4.tables[tableName].columns[columnName];
                        },

                        ALTER: function ALTER() {
                            _this4.optionalToken(['COLUMN']);

                            var columnName = _this4.getIdentifier();
                            var column = _this4.tables[tableName].columns[columnName];

                            _this4.switchToken({
                                'SET DATA TYPE': function SETDATATYPE() {
                                    var dataType = _this4.getIdentifier();
                                    column.dataType = dataType;
                                },

                                'TYPE': function TYPE() {
                                    var dataType = _this4.getIdentifier();
                                    column.dataType = dataType;
                                },

                                'SET DEFAULT': function SETDEFAULT() {
                                    var expression = _this4.getExpression();
                                    column.modifiers.default = expression;
                                },

                                'DROP DEFAULT': function DROPDEFAULT() {
                                    delete column.modifiers.default;
                                },

                                'SET NOT NULL': function SETNOTNULL() {
                                    column.modifiers.notNull = true;
                                },

                                'DROP NOT NULL': function DROPNOTNULL() {
                                    delete column.modifiers.notNull;
                                }
                            });
                        }
                    });

                    return _this4.findToken([',']);
                });
            }
        }
    }, {
        key: 'addIndex',
        value: function addIndex(table, index) {
            if (index.type === 'primaryKey') {
                table.indexes.splice(0, 0, index);
            } else {
                table.indexes.push(index);
            }
        }
    }, {
        key: 'getColumn',
        value: function getColumn(table) {
            var _this5 = this;

            var indexes = [];
            var column = null;

            var constraintName = null;

            this.ifToken(['CONSTRAINT'], function () {
                constraintName = _this5.getIdentifier();
            });

            this.ifToken(['PRIMARY KEY', 'FOREIGN KEY', 'UNIQUE', 'CHECK'], function (token) {
                var type = function (token) {
                    if (token === 'primary key') {
                        return 'primaryKey';
                    } else if (token === 'foreign key') {
                        return 'foreignKey';
                    } else if (token === 'check') {
                        return 'check';
                    }

                    return 'unique';
                }(token.toLowerCase());

                var index = {
                    type: type,
                    columns: [],
                    name: null
                };

                _this5.scope(function () {
                    if (type === 'check') {
                        index.expression = _this5.getInScope();
                    } else {
                        _this5.repeat(function () {
                            var columnName = _this5.getIdentifier();

                            index.columns.push(columnName);

                            return _this5.findToken([',']);
                        });
                    }
                });

                if (type === 'foreignKey') {
                    index.name = constraintName || table.name + '_' + index.columns.join('_') + '_fkey';

                    _this5.getToken(['REFERENCES']);

                    var tableName = _this5.getIdentifier();
                    var referenceColumns = [];

                    _this5.scope(function () {
                        _this5.repeat(function () {
                            var columnName = _this5.getIdentifier();

                            referenceColumns.push(columnName);

                            return _this5.findToken([',']);
                        });
                    });

                    index.tableName = tableName;
                    index.referenceColumns = referenceColumns;
                } else if (type === 'primaryKey') {
                    index.name = constraintName || table.name + '_' + index.columns.join('_') + '_pkey';
                } else if (type === 'unique') {
                    index.name = constraintName || table.name + '_' + index.columns.join('_') + '_key';
                } else if (type === 'check') {
                    // FIXME: the CHECK is actually named based on the expression. If it references one
                    // column it's added to the name. We can't just check if one of the columns is in
                    // the expression, because it checks if it's really a reference.
                    //
                    // Some examples:
                    //  "test_check" CHECK (1 > 0)
                    //  "test_check1" CHECK (123 > 0)
                    //  "test_check2" CHECK (foo_id > val)
                    //  "test_val_check" CHECK (length('foo_id'::text) > val)
                    //  "test_val_check1" CHECK (1 > val AND val < 0)

                    if (constraintName) {
                        index.name = constraintName;
                    } else {
                        var findIndexName = function findIndexName(indexName) {
                            var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

                            var postfix = count === 0 ? '' : String(count);
                            var name = indexName + postfix;

                            var exists = table.indexes.find(function (index) {
                                return index.name === name;
                            });

                            if (exists) {
                                return findIndexName(indexName, count + 1);
                            }

                            return name;
                        };

                        index.name = findIndexName(table.name + '_check');
                    }
                }

                indexes.push(index);
            }, function () {
                column = {
                    // TODO: The name may include the schema e.g. my.table (where "my" is the schema name)?
                    name: _this5.getIdentifier(),
                    dataType: _this5.getUntil(['COLLATE', 'CONSTRAINT', 'NULL', 'NOT NULL', 'CHECK', 'DEFAULT', 'UNIQUE', 'PRIMARY KEY', 'REFERENCES', ',', ')']),
                    modifiers: {}
                };

                _this5.ifToken(['COLLATE'], function () {
                    column.collation = _this5.getIdentifier();
                });

                _this5.repeat(function () {
                    var _this5$switchToken;

                    var constraintName = null;

                    // TODO: Can you name a constraint like this?
                    _this5.ifToken(['CONSTRAINT'], function () {
                        constraintName = _this5.getIdentifier();
                    });

                    var found = _this5.switchToken((_this5$switchToken = {}, (0, _defineProperty3.default)(_this5$switchToken, 'NOT NULL', function undefined() {
                        column.modifiers.notNull = true;
                    }), (0, _defineProperty3.default)(_this5$switchToken, 'NULL', function NULL() {
                        column.modifiers.null = true;
                    }), (0, _defineProperty3.default)(_this5$switchToken, 'CHECK', function CHECK() {
                        var expression = _this5.scope(function () {
                            return _this5.getInScope();
                        });
                        var index = {
                            type: 'check',
                            name: constraintName || table.name + '_' + column.name + '_check',
                            columns: [column.name],
                            expression: expression
                        };

                        _this5.ifToken(['NO INHERIT'], function () {
                            index.noInherit = true;
                        });

                        indexes.push(index);
                    }), (0, _defineProperty3.default)(_this5$switchToken, 'DEFAULT', function DEFAULT() {
                        column.modifiers.default = _this5.getExpression();
                    }), (0, _defineProperty3.default)(_this5$switchToken, 'UNIQUE', function UNIQUE() {
                        var index = {
                            type: 'unique',
                            name: table.name + '_' + column.name + '_key',
                            columns: [column.name]
                        };

                        _this5.ifToken(['WITH'], function () {
                            _this5.scope(function () {
                                index.parameters = [];

                                _this5.repeat(function () {
                                    var storageParameter = _this5.getIdentifier();

                                    if (!_this5.ifToken(['='], function () {
                                        var storageValue = _this5.getIdentifier();

                                        index.parameters.push({
                                            key: storageParameter,
                                            value: storageValue
                                        });
                                    })) {
                                        index.parameters.push({
                                            key: storageParameter,
                                            value: null
                                        });
                                    }

                                    return _this5.findToken([',']);
                                });
                            });
                        });

                        _this5.ifToken(['USING INDEX TABLESPACE'], function () {
                            index.tablespaceName = _this5.getIdentifier();
                        });

                        indexes.push(index);
                    }), (0, _defineProperty3.default)(_this5$switchToken, 'PRIMARY KEY', function undefined() {
                        var index = {
                            type: 'primaryKey',
                            name: table.name + '_pkey',
                            columns: [column.name]
                        };

                        _this5.ifToken(['WITH'], function () {
                            _this5.scope(function () {
                                index.parameters = [];

                                _this5.repeat(function () {
                                    var storageParameter = _this5.getIdentifier();

                                    if (!_this5.ifToken(['='], function () {
                                        var storageValue = _this5.getIdentifier();

                                        index.parameters.push({
                                            key: storageParameter,
                                            value: storageValue
                                        });
                                    })) {
                                        index.parameters.push({
                                            key: storageParameter,
                                            value: null
                                        });
                                    }

                                    return _this5.findToken([',']);
                                });
                            });
                        });

                        _this5.ifToken(['USING INDEX TABLESPACE'], function () {
                            index.tablespaceName = _this5.getIdentifier();
                        });

                        indexes.push(index);
                    }), (0, _defineProperty3.default)(_this5$switchToken, 'REFERENCES', function REFERENCES() {
                        var index = {
                            type: 'foreignKey',
                            name: table.name + '_' + column.name + '_fkey',
                            tableName: _this5.getIdentifier(),
                            columns: [column.name],
                            referenceColumns: []
                        };

                        _this5.scope(function () {
                            _this5.repeat(function () {
                                index.referenceColumns.push(_this5.getIdentifier());
                                return _this5.findToken([',']);
                            });
                        });

                        _this5.ifToken(['MATCH'], function () {
                            index.matchType = _this5.getToken(['FULL', 'PARTIAL', 'SIMPLE']);
                        });

                        _this5.ifToken(['ON DELETE'], function () {
                            var actionType = _this5.getToken(['NO ACTION', 'RESTRICT', 'CASCADE', 'SET NULL', 'SET DEFAULT']);

                            index.onDelete = actionType;
                        });

                        _this5.ifToken(['ON UPDATE'], function () {
                            var actionType = _this5.getToken(['NO ACTION', 'RESTRICT', 'CASCADE', 'SET NULL', 'SET DEFAULT']);

                            index.onUpdate = actionType;
                        });

                        indexes.push(index);
                    }), _this5$switchToken));

                    if (found) {
                        // TODO: Where to apply this to?

                        _this5.ifToken(['DEFERRABLE', 'NOT DEFERRABLE'], function (defferable) {
                            // constraint.defferable = defferable;
                        });

                        _this5.ifToken(['INITIALLY DEFERRED', 'INITIALLY IMMEDIATE'], function (initially) {
                            // constraint.initially = initially;
                        });
                    }

                    return found;
                });
            });

            return {
                column: column,
                indexes: indexes
            };
        }
    }, {
        key: 'simulateCreateType',
        value: function simulateCreateType() {
            var _this6 = this;

            var type = {
                type: 'enum',
                name: this.getIdentifier(),
                labels: []
            };

            this.getToken(['AS']);
            this.getToken(['ENUM']);

            this.scope(function () {
                _this6.repeat(function () {
                    var label = _this6.getString();
                    type.labels.push(label);

                    return _this6.findToken([',']);
                });
            });

            // FIXME: type names and table names may not collide. Because we store them separately, we
            // have no checks for this. Perhaps we should store the tables and types together in a
            // relations map instead?
            this.types[type.name] = type;
        }
    }, {
        key: 'simulateCreateTable',
        value: function simulateCreateTable() {
            var _this7 = this;

            var table = {
                name: null,
                columns: {},
                indexes: []
            };

            this.ifToken(['IF NOT EXISTS'], function () {
                table.ifNotExists = true;
            });

            table.name = this.getIdentifier();

            this.scope(function () {
                _this7.repeat(function () {
                    var _getColumn2 = _this7.getColumn(table),
                        column = _getColumn2.column,
                        indexes = _getColumn2.indexes;

                    if (column) {
                        table.columns[column.name] = column;
                    }

                    indexes.forEach(function (index) {
                        return _this7.addIndex(table, index);
                    });

                    return _this7.findToken([',']);
                });
            });

            // TODO: Parse WITH, ON COMMIT, TABLESPACE
            // TODO: Parse table constraints.

            this.tables[table.name] = table;
        }
    }, {
        key: 'simulateQuery',
        value: function simulateQuery(sql) {
            var _this8 = this;

            this.input = sql.replace(/^\s+/, '');

            var token = this.getToken(['CREATE', 'ALTER', 'DROP', 'SELECT', 'WITH', 'UPDATE', 'DELETE']).toUpperCase();

            if (token === 'SELECT' || token === 'WITH' || token === 'UPDATE' || token === 'DELETE') {
                // These queries do not alter the data structure, so we can ignore them.
                this.input = null;
            } else if (token === 'CREATE') {
                this.ifToken(['GLOBAL', 'LOCAL', 'TEMPORARY', 'TEMP', 'UNLOGGED'], function () {
                    // TODO: It's GLOBAL or LOCAL, TEMPORARY or TEMP, or UNLOGGED. Pass this to the
                    // table.
                });

                this.switchToken({
                    TABLE: function TABLE() {
                        _this8.simulateCreateTable();
                    },

                    TYPE: function TYPE() {
                        _this8.simulateCreateType();
                    }

                    // TODO: TRIGGER, FUNCTION?
                });
            } else if (token === 'ALTER') {
                this.switchToken({
                    TABLE: function TABLE() {
                        _this8.simulateAlterTable();
                    },

                    TYPE: function TYPE() {
                        _this8.simulateAlterType();
                    }
                });
            } else if (token === 'DROP') {
                this.switchToken({
                    TYPE: function TYPE() {
                        _this8.simulateDropType();
                    },

                    TABLE: function TABLE() {
                        _this8.simulateDropTable();
                    }
                });
            }
        }
    }]);
    return Simulator;
}();

exports.default = Simulator;